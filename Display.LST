C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN Display.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Display.c LARGE ROM(COMPACT) OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "display.h"
   2          #include "ziku.h"
   3          #include "key.h"
   4          #include "storage.h"
   5          #include "spd6000.h"
   6          #include "MS4525.h"
   7          #include "pwm.h"
   8          #include "CH4.h"
   9          #include "eeprom.h"
  10          
  11          #define POINT_0 0
  12          #define POINT_1 1
  13          #define POINT_2 2
  14          #define POINT_3 3
  15          
  16          #define ZERO_ADD_REV_1 0x6fe1
  17          #define ZERO_ADD_REV_2 0x6fe2
  18          
  19          #define READ_TIME 10
  20          
  21          sbit  OUT2  = P3^7;
  22          
  23          
  24          void delay( int x)
  25          {
  26   1          int y,z;
  27   1         for(y=x;y>0;y--)
  28   1          {
  29   2                 for(z=100;z>0;z--)
  30   2                  {
  31   3                      }
  32   2              }
  33   1      }
  34          
  35          void key_delay()
  36          {
  37   1         static char num;
  38   1         if(key() != 0)
  39   1           {
  40   2                  num++;
  41   2                      if(num > 20)
  42   2                        {
  43   3                          num = 11;
  44   3                        }
  45   2                 if(num >10)
  46   2                   {
  47   3                         delay(1);
  48   3                       }
  49   2                       else
  50   2                       {
  51   3                         delay(300);
  52   3                       }
  53   2               }
  54   1               else
  55   1               {
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 2   

  56   2                 num =0;
  57   2               }
  58   1         if(num >10)
  59   1           {
  60   2                 delay(10);
  61   2               }
  62   1               else
  63   1               {
  64   2                 delay(1000);
  65   2               }
  66   1      }
  67          
  68          unsigned char return_Main()
  69          {
  70   1                  if(g_iProtect > 900)
  71   1                                 {
  72   2                                    g_cFunc = 0;
  73   2                                    return 1;
  74   2                                 }
  75   1                                 else
  76   1                                 {
  77   2                                    return 0;
  78   2                                 }
  79   1      }
  80          void disylay_mun(unsigned int num,char point,char start_x,char start_y)
  81          {
  82   1        unsigned char temp_num[5];
  83   1        unsigned char temp[6]={0,0,0,0,0,0};
  84   1        unsigned char i=0,j=0;
  85   1        temp_num[0] = num/10000+'0';
  86   1        temp_num[1] = num%10000/1000+'0';
  87   1        temp_num[2] = num%1000/100+'0';
  88   1        temp_num[3] = num%100/10+'0';
  89   1        temp_num[4] = num%10+'0';
  90   1         temp[5-point] = '.';
  91   1        for(i=0;i<6;i++)
  92   1        {
  93   2           if(0 == temp[i])
  94   2               {
  95   3                  temp[i] = temp_num[j];
  96   3                      j++;
  97   3               }
  98   2        }
  99   1        for(i=0;i<4-point;i++)
 100   1               {
 101   2                 if(temp[i] == '0')
 102   2                   {
 103   3                         temp[i] = ' ';
 104   3                       }
 105   2                       else
 106   2                       {
 107   3                         break;
 108   3                       }
 109   2               }
 110   1          if(point>0)
 111   1              {
 112   2                 Display_Onechar(start_x*8,start_y*2,temp[0],0);
 113   2             Display_Onechar((start_x+1)*8,start_y*2,temp[1],0);
 114   2                 Display_Onechar((start_x+2)*8,start_y*2,temp[2],0);
 115   2                 Display_Onechar((start_x+3)*8,start_y*2,temp[3],0);
 116   2                 Display_Onechar((start_x+4)*8,start_y*2,temp[4],0);
 117   2                 Display_Onechar((start_x+5)*8,start_y*2,temp[5],0);
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 3   

 118   2              }
 119   1              else
 120   1              {
 121   2                 Display_Onechar(start_x*8,start_y*2,temp[0],0);
 122   2                 Display_Onechar((start_x+1)*8,start_y*2,temp[1],0);
 123   2                 Display_Onechar((start_x+2)*8,start_y*2,temp[2],0);
 124   2                 Display_Onechar((start_x+3)*8,start_y*2,temp[3],0);
 125   2                 Display_Onechar((start_x+4)*8,start_y*2,temp[4],0);
 126   2              }
 127   1      }
 128          
 129          void display_stringChar(unsigned char start_x,unsigned char start_y,char* s)
 130          {
 131   1            unsigned char i=0;
 132   1                while(*s != '\0')
 133   1                {
 134   2                   Display_Onechar((start_x+i)*8,start_y*2,*s,0);
 135   2                       i++;
 136   2                       s++;
 137   2                }       
 138   1      }
 139          
 140          void display_stringChinese(unsigned char start_x,unsigned char start_y,unsigned char** s)
 141          {
 142   1        unsigned char i=0;
 143   1        for(i=0;i<5;i++)
 144   1        {
 145   2         Display_Graphic(start_x*8+i*16,start_y*2,16,16,*s,0);
 146   2         s++;
 147   2         }
 148   1      }
 149          
 150          void display_sum(long sum,char start_x,char start_y)
 151          {
 152   1         unsigned char temp[9] = {0,0,0,0,0,0,0,0};
 153   1         char i;
 154   1         if(sum>999999999)
 155   1         {
 156   2           sum = 999999999;
 157   2         }
 158   1         temp[0] = sum/100000000L+'0';
 159   1         temp[1] = sum%100000000L/10000000L+'0';
 160   1         temp[2] = sum%10000000L/1000000L+'0';
 161   1         temp[3] = sum%1000000L/100000L+'0';
 162   1         temp[4] = sum%100000L/10000L+'0';
 163   1         temp[5] = sum%10000L/1000L+'0';
 164   1         temp[6] = sum%1000L/100L+'0';
 165   1         temp[7] = sum%100L/10L+'0';
 166   1         temp[8] = sum%10L+'0';
 167   1      
 168   1         for(i=0;i<8;i++)
 169   1               {
 170   2                 if(temp[i] == '0')
 171   2                   {
 172   3                         temp[i] = ' ';
 173   3                       }
 174   2                       else
 175   2                       {
 176   3                         break;
 177   3                       }
 178   2               }
 179   1         for(i=0;i<9;i++)
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 4   

 180   1         {
 181   2            Display_Onechar((start_x+i)*8,start_y*2,temp[i],0);
 182   2         }
 183   1      }
 184           
 185          void read_senser(float* p_flux,float* p_pase,float ch4,float* tmpter)
 186          {
 187   1              float ch4_temp;
 188   1                      float temp = 0;
 189   1              //      static int num = 0;
 190   1                         ch4_temp = ch4;
 191   1                         if(ch4_temp<0.001)
 192   1                            {
 193   2                                   ch4_temp= 0.0;
 194   2                                }
 195   1                // *p_pase = date_Smooth_4525(tmpter); //读取绝压值
 196   1      
 197   1                         temp = Wid_Speed(p_pase,tmpter);
 198   1                        
 199   1                     if(g_cUint == 0)
 200   1                         {
 201   2                          if(g_cWorkChange == 1)      //工况
 202   2                              {
 203   3                            *p_flux =  temp*g_iArea/10000;
 204   3                              }
 205   2                              else  //标况
 206   2                              {
 207   3                               *p_flux =  temp*g_iArea/10000*(*p_pase/101.325)*(293/(273+*tmpter));
 208   3                              }
 209   2                              if(*p_flux>g_iRange)
 210   2                                {                                        
 211   3                                   *p_flux = g_iRange;
 212   3                                }
 213   2                        }
 214   1                        else
 215   1                        {
 216   2                          if(g_cWorkChange == 1)
 217   2                              {
 218   3                            *p_flux =  temp*g_iArea/10000*60;
 219   3                              }
 220   2                              else
 221   2                              {
 222   3                                *p_flux =  temp*g_iArea/10000*60*(*p_pase/101.325)*(293/(273+*tmpter));
 223   3                              }
 224   2                          if(*p_flux>g_iRangeMin)
 225   2                                {
 226   3                                   *p_flux = g_iRangeMin;
 227   3                                } 
 228   2                       }
 229   1      }
 230             
 231          
 232          
 233          void read_Maxout()
 234          {
 235   1         float p_flux;
 236   1         float p_pase;
 237   1         float ch4;
 238   1         static char flag=0;
 239   1         static char flag1=0;
 240   1         float temper;
 241   1      
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 5   

 242   1         if(g_iTime < 10 && flag1 ==0)        //每一小时保存一次
 243   1                      {
 244   2                        if(g_cMaxOut == 0 || g_cMaxOut == 2)
 245   2                         {
 246   3                          Dateeprom();
 247   3                         }
 248   2                         flag1 = 1;
 249   2                      }
 250   1                      else if(g_iTime > 10)
 251   1                       {
 252   2                         flag1 = 0;
 253   2                       }
 254   1      
 255   1        // if(g_iTimebase <= 10 && flag == 0 )
 256   1         if(g_iTime%57 < 20 && flag ==0 )     //每一分钟计算一次
 257   1         {
 258   2              flag = 1;
 259   2              ch4 = read_ch4();
 260   2                      if(ch4 < 0.001)
 261   2                        {
 262   3                           ch4 =0.0;
 263   3                        }
 264   2                // p_pase = date_Smooth_4525(&temper); //读取绝压值
 265   2                        p_flux = Wid_Speed(&p_pase,&temper)*g_iArea/10000;
 266   2                     
 267   2                       if(g_cUint == 0)
 268   2                        {
 269   3                               g_fSum = g_fSum + p_flux;
 270   3                               g_fSum_biao = g_fSum_biao +  p_flux*(p_pase/101.325)*(293/(273+temper));
 271   3                               g_fSum_biao_ch4 = g_fSum_biao_ch4 + p_flux*(p_pase/101.325)*(293/(273+temper))*ch4/100;
 272   3                        }
 273   2                        else
 274   2                        {
 275   3                            g_fSum = g_fSum + p_flux*60 ;
 276   3                                g_fSum_biao = g_fSum_biao + p_flux*60*(p_pase/101.325)*(293/(273+temper));
 277   3                                g_fSum_biao_ch4 = g_fSum_biao_ch4 + p_flux*60*(p_pase/101.325)*(293/(273+temper))*ch4/100;
 278   3                        }
 279   2              }
 280   1              else if(g_iTime%57 > 20)
 281   1              {
 282   2                 flag = 0;
 283   2              }
 284   1      }       
 285          /*
 286            显示压力界面
 287          */
 288          unsigned char display_Preassure()
 289          {
 290   1              unsigned char key_num;
 291   1              unsigned int preassure;
 292   1          code unsigned char* chinese[] ={font_13,font_14,font_00,font_00,font_00};
 293   1          code char arr[] = {'p','a','\0'};
 294   1              char flag=0;
 295   1          preassure = date_Smooth();
 296   1              display_stringChinese(0,0,chinese);
 297   1              display_stringChar(6,1,arr);
 298   1              disylay_mun(preassure,0,0,1); 
 299   1      
 300   1              while(1)
 301   1              {
 302   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 303   2                      {
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 6   

 304   3                    read_Maxout();
 305   3                      }
 306   2                      key_num = key();
 307   2                      if(key_num == KEY_FUNC)
 308   2                      {
 309   3                          g_iProtect = 0;
 310   3                      g_cFunc++;
 311   3                              key_release();
 312   3                      return 0;
 313   3                      }
 314   2      
 315   2                           if(0 == flag && g_iTimebase <= 5  )
 316   2                                       {
 317   3                                          flag = 1;
 318   3                                              preassure = date_Smooth();
 319   3                                  disylay_mun(preassure,0,0,1);
 320   3                                       }
 321   2                                       else if(g_iTimebase>5)
 322   2                                        {
 323   3                                           flag = 0 ;
 324   3                                        }
 325   2      
 326   2                      key_delay();
 327   2                  if(return_Main())
 328   2                      {
 329   3                              return 0;
 330   3                      }
 331   2              }
 332   1            return 0;
 333   1      }
 334          
 335          unsigned char display_Area()
 336          {
 337   1              unsigned char key_num;
 338   1              unsigned int area;
 339   1              unsigned int temp_area;
 340   1         code unsigned char* chinese[] ={font_11,font_12,font_07,font_00,font_00,font_00};    //截面积
 341   1         code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};          //密码2
 342   1         code char arr[] = {'c','m',60,'\0'};
 343   1             area = g_iArea;
 344   1                 temp_area = area;
 345   1              display_stringChinese(0,0,chinese);
 346   1              display_stringChar(5,1,arr);
 347   1              disylay_mun(area,0,0,1); 
 348   1              while(1)
 349   1              {
 350   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 351   2                  read_Maxout();
 352   2                      key_num = key();
 353   2                      if(key_num == KEY_FUNC)
 354   2                      {
 355   3                          g_iProtect = 0;
 356   3                      g_cFunc++;
 357   3                              key_release();
 358   3                      return 0;
 359   3                      }
 360   2              area = key_AddSub(area,0,0,1,10000);
 361   2                      if(key_num == KEY_SURE)
 362   2                      {
 363   3                         g_iProtect = 0;
 364   3                         g_iArea = area;
 365   3                         Clean_Display(0,0,128,64,0);
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 7   

 366   3                         if(display_Protect1(chinese2,10) == 0)
 367   3                           {
 368   4                                  g_iArea = temp_area;
 369   4                                      area = g_iArea;
 370   4                               }
 371   3                               else
 372   3                               {
 373   4                                 Dateeprom();
 374   4                               }
 375   3                         Clean_Display(0,0,128,64,0);
 376   3                         display_stringChinese(0,0,chinese);
 377   3                         display_stringChar(5,1,arr);
 378   3                         disylay_mun(area,0,0,1);
 379   3                      }
 380   2                      key_delay();
 381   2                  if(return_Main())
 382   2                      {
 383   3                              return 0;
 384   3                      }
 385   2              //      disylay_mun(100,2,0,2);
 386   2              }
 387   1      }
 388          
 389          void mian1_chinese()
 390          {
 391   1        unsigned char* chineseWork[] ={gong,kuang,font_00,font_00,font_00};     //工况
 392   1         unsigned char* chineseStandar[] ={biao,kuang,font_00,font_00,font_00}; //标况
 393   1        //code unsigned char* chineseFlux[] ={font_38,font_02,font_37,font_00,font_00};        //流量  此处应改成工况
 394   1        code unsigned char* chinesePase[] = {font_13,font_14,font_00,font_00,font_00}; //压力
 395   1        code unsigned char* chineseCH4[] = {jia,wan,font_00,font_00,font_00}; //甲烷
 396   1        //code unsigned char*  chineseMin[] = {font_32,font_33,font_34,font_35,font_36};//流量变送器
 397   1        //unsigned char * code chineseisch4[] = {chun,font_02,font_37,font_00,font_00};        //纯量  此处应改成标况
 398   1        unsigned char *code chineseTmp[] = {font_41,font_42,font_00,font_00,font_00};  //温度
 399   1      
 400   1      //   code char arrm3[] = {'m',59,'\0'};
 401   1      
 402   1         code char arr[] = {':','\0'};
 403   1         code char arrS[] = {'m',59,'/','s','\0'};     //m3/s
 404   1         code char arrMin[] = {'m',59,'/','m','i','n','\0'}; //m3/min
 405   1         code char arrKPa[] = {'K','P','a','\0'};
 406   1       //  code char arrERR[] = {' ','-','-',' ',' ',' ',' ','\0'};
 407   1         code char arrch4[]   = {'%','\0'};
 408   1         code char arrTmper[] = {34,'C','\0'};
 409   1               
 410   1          if(g_cWorkChange == 1)
 411   1              { 
 412   2                display_stringChinese(0,0,chineseWork);        //显示中文
 413   2              }
 414   1              else
 415   1              {
 416   2                display_stringChinese(0,0,chineseStandar);    
 417   2              }
 418   1              /*显示流量单位*/
 419   1                if(g_cUint == 0)
 420   1                {
 421   2                      display_stringChar(12,0,arrS);
 422   2                }
 423   1                else
 424   1                {
 425   2                  display_stringChar(10,0,arrMin);
 426   2                }
 427   1               display_stringChar(4,0,arr);
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 8   

 428   1              display_stringChinese(0,1,chinesePase);  //显示中文压力
 429   1              display_stringChar(4,1,arr);
 430   1              display_stringChar(13,1,arrKPa);         //显示绝压单位 
 431   1      
 432   1              display_stringChinese(0,2,chineseCH4);  //显示甲烷中文两个字
 433   1              display_stringChar(4,2,arr);
 434   1              display_stringChar(15,2,arrch4);           //显示甲烷中的%
 435   1              //display_stringChar(5,2,arrERR);                  //显示甲烷中的--
 436   1      
 437   1              display_stringChinese(0,3,chineseTmp);//显示温度字样
 438   1              display_stringChar(4,3,arr);
 439   1              display_stringChar(14,3,arrTmper);
 440   1      }
 441          
 442          void mian1_num(char i)
 443          {
 444   1         float pase;
 445   1         float flux;
 446   1         float ch4;
 447   1         float tmper;
 448   1         static float flux_sum =0.0;
 449   1         static float flux_sum_old =0.0;
 450   1         static char flux_num_1 = 0;
 451   1         static char flux_num_2 = 0;
 452   1        // static char first_flag = 1;
 453   1         code char arrERR[] = {' ','-','-',' ',' ',' ',' ','\0'};
 454   1         code char arr[] = {':','\0'};
 455   1      
 456   1                              ch4= read_ch4();
 457   1                                          read_senser(&flux,&pase,ch4,&tmper);
 458   1                                      disylay_mun(tmper*10,POINT_1,8,3);
 459   1                                                      
 460   1                                                                               
 461   1                                         if(pase<1.0)
 462   1                                         {
 463   2                                            display_stringChar(5,1,arrERR);   //显示--
 464   2                                                CR = 0;                         //PCA timer start run
 465   2                                    EPCAI = 0;
 466   2                                                OUT2 = 1;
 467   2                                         }
 468   1                                         else
 469   1                                         {
 470   2                                        disylay_mun(pase*10,POINT_1,7,1);      //显示绝压的数据
 471   2                                            CR = 1;                         //PCA timer start run
 472   2                                    EPCAI = 1;
 473   2                                            pca_set2(pase);//设置绝压的输出脉冲
 474   2                                         }
 475   1                                         
 476   1                                         /*设置甲烷的数据*/
 477   1                                         if(ch4 >= 0.0 && ch4 < 100.001)
 478   1                                              {
 479   2                                                  disylay_mun(ch4*10,POINT_1,9,2);    //显示甲烷的百分比
 480   2                                              }
 481   1                                              else
 482   1                                              {
 483   2                                                      display_stringChar(5,2,arrERR); //显示--
 484   2                                              }
 485   1                                        if(i == 0)
 486   1                                         {
 487   2                          flux_num_1++;
 488   2                                          flux_sum =flux_sum + flux;
 489   2                                         }
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 9   

 490   1                                        if(10 == flux_num_1 || i == 1)
 491   1                                              {
 492   2                                               
 493   2                                               if(i == 1)
 494   2                                               {
 495   3                                                  flux = flux_sum_old ;
 496   3                                               }
 497   2                                               else
 498   2                                               {
 499   3                                                flux_num_1 = 0;
 500   3                                                flux = flux_sum/10;
 501   3                                                flux_sum_old = flux;
 502   3                                                flux_sum = 0.0;
 503   3                                               }
 504   2                                               flux_num_2++;
 505   2                                               if(flux_num_2 == 4 || i == 1)
 506   2                                               {
 507   3                                                  i = 0;
 508   3                                                  flux_num_2=0;
 509   3                                               if(g_cUint == 0)         //在秒单位下的流量显示
 510   3                                                 {
 511   4                                                  disylay_mun(flux*100,POINT_2,6,0);
 512   4                                                  g_cOut1[0] = (65536-500000/(200+800.0/g_iRange*((float)flux))+3)/256; 
 513   4                                                  g_cOut1[1] = (65536-500000/(int)(200+800.0/g_iRange*(float)flux)+3)%256;
 514   4                                                 }
 515   3                                                 else
 516   3                                                 {
 517   4                                               if(flux>g_iRangeMin)
 518   4                                                        {
 519   5                                                           flux = g_iRangeMin;
 520   5                                                        }
 521   4                                                         if(flux<100)
 522   4                                                          {
 523   5                                                           disylay_mun(flux*100,POINT_2,4,0);
 524   5                                                               display_stringChar(4,0,arr);
 525   5                                                              }
 526   4                                                              else
 527   4                                                              {
 528   5                                                               if(flux>999.9)
 529   5                                                                 {
 530   6                                                                   flux = 999.9;
 531   6                                                                 }
 532   5                                                                disylay_mun(flux*10,POINT_1,4,0);
 533   5                                                                display_stringChar(4,0,arr);
 534   5                                                              }
 535   4                                                              g_cOut1[0] = (65536-500000/(200+800.0/g_iRangeMin*flux)+3)/256;  
 536   4                                                      g_cOut1[1] = (unsigned int)(65536-500000/(200+800.0/g_iRangeMin*flux)+3)%256;
 537   4                                                 }
 538   3                                                }
 539   2                                                      
 540   2                                      }
 541   1      
 542   1      }
 543          
 544          void mian2_chinese()
 545          {
 546   1      
 547   1         unsigned char* chinese[] ={zong,font_02,font_00,font_00,font_00};      //总量
 548   1         unsigned char* chineseWork[] ={gong,kuang,font_00,font_00,font_00};    //工况
 549   1         unsigned char* chineseStandar[] ={biao,kuang,font_00,font_00,font_00}; //标况
 550   1         unsigned char* chineseStandar_cun[] ={biao,chun,font_00,font_00,font_00}; //  标纯
 551   1         unsigned char* chineseClear[] ={qing,font_03,font_00,font_00,font_00};         //清零选择
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 10  

 552   1         code char arrOFF[] = {'O','F','F',' ','\0'};
 553   1         code char arrON[] =  {'O','N',' ',' ','\0'};
 554   1         code char arrm3[] = {'m',59,'\0'};
 555   1         code char arr[] = {':','\0'};
 556   1            
 557   1              Clean_Display(0,0,128,64,0);  
 558   1                      display_stringChinese(0,0,chinese);     //总量
 559   1                      display_stringChar(4,0,arr); //总量后面的：                     
 560   1                      if(g_cMaxOut == 1)
 561   1                       {
 562   2                           display_stringChar(7,0,arrOFF);
 563   2                       }
 564   1                      else if(g_cMaxOut == 0)
 565   1                       {
 566   2                               display_stringChar(7,0,arrON);
 567   2                       }
 568   1                  else
 569   1                       {
 570   2                               display_stringChinese(7,0,chineseClear);
 571   2                       }
 572   1                       /*显示工况和其单位*/
 573   1                      display_stringChinese(0,1,chineseWork);
 574   1              display_stringChar(14,1,arrm3);
 575   1              display_stringChar(4,1,arr);
 576   1      
 577   1                      /*显示标况和其单位*/
 578   1                      display_stringChinese(0,2,chineseStandar);
 579   1              display_stringChar(14,2,arrm3);
 580   1              display_stringChar(4,2,arr);
 581   1      
 582   1                      /*显示纯标和其单位*/
 583   1                      display_stringChinese(0,3,chineseStandar_cun);
 584   1              display_stringChar(14,3,arrm3);
 585   1                      display_stringChar(4,3,arr);
 586   1      }
 587          
 588          
 589          unsigned char display_Main()
 590          {
 591   1         unsigned char key_num;
 592   1         char flag=0;
 593   1         char flag_ret1 = 1;
 594   1         char flag_ret2 = 1;
 595   1         mian1_chinese();
 596   1         mian1_num(1);
 597   1         
 598   1              while(1)
 599   1              {   
 600   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 601   2                      {
 602   3                              read_Maxout();
 603   3                      }
 604   2                      key_num = key();        //检查按键
 605   2                                      if(key_num == KEY_FUNC)
 606   2                                      {
 607   3                                         if(g_iProtect>=900)   //在第一次按下时跳转到密码一界面，不然跳转跳转到正常的下一个界面
 608   3                                         {
 609   4                                               g_cFunc = 15;
 610   4                                         }
 611   3                                         else
 612   3                                         {
 613   4                                       g_cFunc++;
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 11  

 614   4                                         }
 615   3                                         g_iProtect = 0;
 616   3                                              key_release();  //按键释放
 617   3                                      return 0;
 618   3                                      }
 619   2                  if(g_iTime%30 < 20 )         //在前20s显示第一种界面
 620   2                      {
 621   3                              if(flag_ret1 == 1)
 622   3                                        {
 623   4                                          Clean_Display(0,0,128,64,0);
 624   4                                              mian1_chinese();
 625   4                                              mian1_num(1);
 626   4                                        }
 627   3                                       flag_ret1 = 0;
 628   3                                       flag_ret2 = 1;
 629   3      
 630   3                                  
 631   3                                      
 632   3                                         
 633   3                                      /*读取绝压和差压的传感器并显示*/
 634   3                                      // if(flag == 0 && (g_iTimebase <= 5 || (g_iTimebase >=10 && g_iTimebase<=15)) )
 635   3                                      if(0 == flag && g_iTimebase <= 5  )
 636   3                                       {
 637   4                                          flag = 1;
 638   4                                              mian1_num(0);
 639   4                                       }
 640   3                                       else if(g_iTimebase>5)
 641   3                                        {
 642   4                                           flag = 0 ;
 643   4                                        }
 644   3                      }
 645   2                      else
 646   2                      {
 647   3                        if(flag_ret2 == 1)
 648   3                              {
 649   4                                Clean_Display(0,0,128,64,0);
 650   4                        mian2_chinese();                                              
 651   4                              }
 652   3                              flag_ret1 = 1;
 653   3                              flag_ret2 = 0;
 654   3                              if(0 == flag && g_iTimebase <= 5  )
 655   3                              {
 656   4                                          flag = 1;
 657   4                                              display_sum(g_fSum,5,1); //显示工况累积值
 658   4                                              display_sum(g_fSum_biao,5,2); //显示工况累积值
 659   4                                              display_sum(g_fSum_biao_ch4,5,3);
 660   4                                              
 661   4      
 662   4                              }
 663   3                              else if(g_iTimebase>5)
 664   3                              {
 665   4                                           flag = 0 ;
 666   4                              }                 
 667   3                      }
 668   2              }
 669   1      }
 670          
 671          unsigned char display_WindSpeed()
 672          {
 673   1              unsigned char key_num;
 674   1              float windSpeed;
 675   1              unsigned int play;
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 12  

 676   1              float pase,temper;
 677   1          code unsigned char* chinese[] ={font_38,font_04,font_00,font_00,font_00};  //流速
 678   1          code char arr[] = {'m','/','s','\0'};
 679   1      
 680   1              display_stringChinese(0,0,chinese);
 681   1              display_stringChar(6,1,arr);
 682   1              windSpeed = Wid_Speed(&pase,&temper);
 683   1              play = windSpeed*10;
 684   1              disylay_mun(play,1,0,1); 
 685   1      
 686   1              while(1)
 687   1              {
 688   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 689   2                  read_Maxout();
 690   2                      key_num = key();
 691   2                      if(key_num == KEY_FUNC)
 692   2                      {
 693   3                          g_iProtect = 0;
 694   3                      g_cFunc++;
 695   3                              key_release();
 696   3                      return 0;
 697   3                      }
 698   2      
 699   2                  if((g_iTimebase%READ_TIME) == 0)
 700   2                       {
 701   3                          windSpeed = Wid_Speed(&pase,&temper);
 702   3                              play =windSpeed*10;
 703   3                              disylay_mun(play,POINT_1,0,1);
 704   3                       }
 705   2                      key_delay();
 706   2                  if(return_Main())
 707   2                      {
 708   3                              return 0;
 709   3                      }
 710   2              }
 711   1      }
 712          
 713          unsigned char display_WindSpeedZero()
 714          {
 715   1          char i;
 716   1              char error;
 717   1              unsigned char key_num;
 718   1              float windSpeed;
 719   1          int pressure = 0;
 720   1              unsigned int temper;
 721   1              float pressure_sum = 0;
 722   1          int play;
 723   1              float pase,tmpter;
 724   1          code unsigned char* chinese[] ={font_03,font_24,font_05,font_06,font_00};     //零点校准
 725   1              code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};     //密码2
 726   1          code char arr[] = {'m','/','s','\0'};
 727   1      
 728   1              display_stringChinese(0,0,chinese);
 729   1              display_stringChar(6,1,arr);
 730   1              windSpeed = Wid_Speed(&pase,&tmpter);
 731   1              play =  (int)(windSpeed*10);
 732   1              disylay_mun(play,1,0,1);  
 733   1              while(1)
 734   1              {
 735   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 736   2                  read_Maxout();
 737   2                      key_num = key();
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 13  

 738   2                      if(key_num == KEY_FUNC)
 739   2                      {
 740   3                          g_iProtect = 0;
 741   3                      g_cFunc++;
 742   3                              key_release();
 743   3                      return 0;
 744   3                      }
 745   2                      if(key_num == KEY_SURE)
 746   2                        {
 747   3                          g_iProtect = 0;
 748   3                          key_release();
 749   3                         Clean_Display(0,0,128,64,0);
 750   3                         if(display_Protect1(chinese2,10) == 1 )
 751   3                         {
 752   4                                i =0;
 753   4                                      while(i<5)
 754   4                                         {
 755   5                                             error = MS4515DO_read((unsigned char*)&pressure,(unsigned char*)&temper);
 756   5                                      //         MS4515DO_read((unsigned char*)&dat1,(unsigned char*)temper) == 0
 757   5                                                  if( error == 0)
 758   5                                                      {
 759   6                                                         i++;
 760   6                                                              if(pressure<=1638)
 761   6                                                          {
 762   7                                                                pressure = 1638;
 763   7                                                      }
 764   6                                                    if(pressure>=14746)
 765   6                                                  {
 766   7                                                            pressure = 14746;
 767   7                                                      }
 768   6                                                       pressure_sum =pressure_sum+pressure;
 769   6                                                       
 770   6                                                      }
 771   5                              //                      disylay_mun(i,0,7,2);
 772   5                                                      delay(500);
 773   5                                         }   
 774   4                                         pressure_sum = pressure_sum/5;
 775   4                                         g_fZero = pressure_sum*0.07751938-635;
 776   4                                         g_fZero_rev = g_fZero;
 777   4                                         Dateeprom(); 
 778   4                         }
 779   3                         Clean_Display(0,0,128,64,0);
 780   3                         display_stringChinese(0,0,chinese);
 781   3                         display_stringChar(6,1,arr);
 782   3                              windSpeed = Wid_Speed(&pase,&tmpter);
 783   3                      play =  (int)(windSpeed*10);
 784   3                      disylay_mun(play,1,0,1);
 785   3                      
 786   3                        }
 787   2                      if((g_iTimebase%READ_TIME) == 0)
 788   2                        {
 789   3                          windSpeed = Wid_Speed(&pase,&tmpter);
 790   3                              play =  (int)(windSpeed*10);
 791   3                              disylay_mun(play,1,0,1);
 792   3      //                      disylay_mun(g_fZero*100,2,0,2);   //调试用，显示零点值为多少
 793   3                        }
 794   2                      key_delay();
 795   2                  if(return_Main())
 796   2                      {
 797   3                              return 0;
 798   3                      }
 799   2              }
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 14  

 800   1      }
 801          
 802          unsigned char display_WindSpeedRate()
 803          {
 804   1              unsigned char key_num;
 805   1              float windSpeed;
 806   1              unsigned int play;
 807   1              float k1;
 808   1              float pase,tmpter;
 809   1         code unsigned char* chinese[] ={font_26,font_27,font_05,font_06,font_00};      //精度校准
 810   1         code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};          //密码2
 811   1         code char arr[] = {'m','/','s','\0'};
 812   1           k1=g_fK1;
 813   1              display_stringChinese(0,0,chinese);
 814   1              display_stringChar(6,1,arr);
 815   1              windSpeed = Wid_Speed(&pase,&tmpter);
 816   1              play =  (int)(windSpeed*10);
 817   1              disylay_mun(play,1,0,1); 
 818   1              while(1)
 819   1              {
 820   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 821   2                  read_Maxout();
 822   2                      key_num = key();
 823   2                      if(key_num == KEY_FUNC)
 824   2                      {
 825   3                          g_iProtect = 0;
 826   3                      g_cFunc++;
 827   3                              g_fK1 = k1;
 828   3                              key_release();
 829   3                      return 0;
 830   3                      }
 831   2      
 832   2                      if(key_num == KEY_ADD)
 833   2                        {
 834   3                         g_iProtect = 0;
 835   3                         windSpeed = Wid_Speed(&pase,&tmpter); 
 836   3                         g_fK1 = (windSpeed+0.1)/windSpeed*g_fK1;
 837   3                     if(g_fK1 >= 20)
 838   3                              {
 839   4                                g_fK1 = 20;
 840   4                          }
 841   3                         if(g_fK1 <= 0.1)
 842   3                              {
 843   4                                g_fK1 = 0.1;
 844   4                          }
 845   3                              windSpeed = Wid_Speed(&pase,&tmpter);
 846   3                              play =  (int)(windSpeed*10);
 847   3                              disylay_mun(play,1,0,1);  
 848   3                        }
 849   2                        
 850   2                        if(key_num == KEY_SUB)
 851   2                        {
 852   3                         g_iProtect = 0;
 853   3                         windSpeed = Wid_Speed(&pase,&tmpter); 
 854   3                         g_fK1 = (windSpeed-0.1)/windSpeed*g_fK1;
 855   3                     if(g_fK1 >= 20)
 856   3                              {
 857   4                                g_fK1 = 20;
 858   4                          }
 859   3                         if(g_fK1 <= 0.1)
 860   3                              {
 861   4                                g_fK1 = 0.1;
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 15  

 862   4                          }
 863   3                              windSpeed = Wid_Speed(&pase,&tmpter);
 864   3                              play =  (int)(windSpeed*10);
 865   3                              disylay_mun(play,POINT_1,0,1);  
 866   3                        }
 867   2      
 868   2                        if(key_num == KEY_SURE)
 869   2                        {
 870   3                          g_iProtect = 0;
 871   3                         Clean_Display(0,0,128,64,0);
 872   3                         if(display_Protect1(chinese2,10) == 0)
 873   3                           {
 874   4                                  
 875   4                                  g_fK1 = k1;
 876   4                               }
 877   3                               else
 878   3                               {
 879   4                                 Dateeprom();
 880   4                                 k1 = g_fK1;
 881   4                               }
 882   3                         Clean_Display(0,0,128,64,0);
 883   3                         display_stringChinese(0,0,chinese);
 884   3                              windSpeed = Wid_Speed(&pase,&tmpter);
 885   3                      play =  (int)(windSpeed*10);
 886   3                 disylay_mun(play,POINT_1,0,1);
 887   3                       //  disylay_mun(range,2,3,1);  
 888   3                        }
 889   2                       if(g_iTimebase == 1)
 890   2                       {
 891   3                         windSpeed = Wid_Speed(&pase,&tmpter);
 892   3                              play =  (int)(windSpeed*10);
 893   3                              disylay_mun(play,POINT_1,0,1);
 894   3                       }
 895   2                      key_delay();
 896   2                  if(return_Main())
 897   2                      {
 898   3                         // g_fK1 = k1;
 899   3                              return 0;
 900   3                      }
 901   2              //      disylay_mun(100,2,0,2);
 902   2              }
 903   1      }
 904          
 905          unsigned char display_Rate()
 906          {
 907   1              unsigned char key_num;
 908   1         unsigned int range , temp ;
 909   1          float temp_K2;                                              
 910   1         code unsigned char* chinese[] = {font_39,font_40,font_09,font_10,font_00};     //补偿系数
 911   1         code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};          //密码2
 912   1          range = g_fK2*100;
 913   1              temp_K2 = g_fK2;
 914   1       //  char arr[] = {'m','/','s','\0'};
 915   1              display_stringChinese(0,0,chinese);
 916   1      //      display_stringChar(6,1,arr);
 917   1          disylay_mun(range,2,0,1); 
 918   1              while(1)
 919   1              {
 920   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 921   2                  read_Maxout();
 922   2                      key_num = key();
 923   2                      if(key_num == KEY_FUNC)
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 16  

 924   2                      {
 925   3                          g_iProtect = 0;
 926   3                      g_cFunc++;
 927   3                              key_release();
 928   3                      return 0;
 929   3                      }
 930   2                      temp = key_AddSub(range,2,0,1,200);
 931   2                      range = temp;
 932   2                      if(key_num == KEY_SURE)
 933   2                      {
 934   3                         g_iProtect = 0;
 935   3                         g_fK2 = (float)range/100;
 936   3                         Clean_Display(0,0,128,64,0);
 937   3                         if(display_Protect1(chinese2,10) == 0)
 938   3                           {
 939   4                                
 940   4                                  g_fK2 = temp_K2;
 941   4                                      range = g_fK2*100;
 942   4                               }
 943   3                               else
 944   3                               {
 945   4                                   Dateeprom();
 946   4                               }
 947   3                         Clean_Display(0,0,128,64,0);
 948   3                         display_stringChinese(0,0,chinese);
 949   3                         disylay_mun(range,2,0,1);
 950   3                      }
 951   2                       key_delay();
 952   2                  if(return_Main())
 953   2                      {
 954   3                              return 0;
 955   3                      }
 956   2              //      disylay_mun(100,2,0,2);
 957   2              }
 958   1      }
 959          
 960          unsigned char display_Renew()
 961          {
 962   1              unsigned char key_num;
 963   1              unsigned char integral,temp;
 964   1              unsigned char temp_integral;
 965   1          code unsigned char* chinese[] ={font_07,font_08,font_09,font_10,font_00};     //积分系数
 966   1          code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};         //密码2
 967   1       //  char arr[] = {'m','/','s','\0'};
 968   1          integral = g_cIntegral;
 969   1              temp_integral = g_cIntegral;
 970   1              display_stringChinese(0,0,chinese);
 971   1              disylay_mun(g_cIntegral,0,0,1);
 972   1      //      display_stringChar(6,1,arr); 
 973   1              while(1)
 974   1              {
 975   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 976   2                  read_Maxout();
 977   2                      key_num = key();
 978   2                      if(key_num == KEY_FUNC)
 979   2                      {
 980   3                          g_iProtect = 0;
 981   3                      g_cFunc++;
 982   3                              key_release();
 983   3                      return 0;
 984   3                      }
 985   2                      temp = key_AddSub(integral,0,0,1,19);
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 17  

 986   2                       integral  = temp;
 987   2              if(key_num == KEY_SURE)
 988   2                      {
 989   3                         g_iProtect = 0;
 990   3                         g_cIntegral = integral;
 991   3                         Clean_Display(0,0,128,64,0);
 992   3                         if(display_Protect1(chinese2,10) == 0)
 993   3                         {
 994   4                           
 995   4                           g_cIntegral = temp_integral;
 996   4                               integral = g_cIntegral; 
 997   4                         }
 998   3                         else
 999   3                         {
1000   4                           Dateeprom();
1001   4                         }
1002   3                         Clean_Display(0,0,128,64,0);
1003   3                         display_stringChinese(0,0,chinese);
1004   3                         disylay_mun(integral,0,0,1);
1005   3                      }
1006   2      
1007   2                      key_delay();
1008   2                  if(return_Main())
1009   2                      {
1010   3                              return 0;
1011   3                      }
1012   2                      
1013   2              //      disylay_mun(100,2,0,2);
1014   2              }
1015   1      }
1016          
1017          unsigned char display_ZKSet()
1018          {
1019   1              unsigned char key_num;
1020   1              float k1,zero;
1021   1              unsigned char temp1,temp2;
1022   1         code unsigned char* chinese[] ={font_17,font_18,font_25,font_28,font_29};      //恢复初始值
1023   1         code unsigned char* chinese1[] ={font_30,font_29,font_00,font_00,font_00};  //原值
1024   1         code unsigned char* chinese2[] ={font_31,font_29,font_00,font_00,font_00};   //新值
1025   1         code unsigned char* chinese3[] ={font_22,font_23,er,font_00,font_00};          //密码2
1026   1       //  char arr[] = {'m','/','s','\0'};
1027   1             k1 = g_fK1;
1028   1                 zero = g_fZero;
1029   1              display_stringChinese(0,0,chinese);
1030   1      //      display_stringChar(6,1,arr); 
1031   1           if((g_fZero>(g_fZero_rev-0.01)&&g_fZero<(g_fZero_rev+0.01)) && g_fK1>0.99 && g_fK1<1.01 )
1032   1                 {
1033   2                    display_stringChinese(0,1,chinese1);
1034   2                 }
1035   1                 else
1036   1                 {
1037   2                    display_stringChinese(0,1,chinese2);
1038   2                 }
1039   1              while(1)
1040   1              {
1041   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1042   2                  read_Maxout();
1043   2                      key_num = key();
1044   2                      if(key_num == KEY_FUNC)
1045   2                      {
1046   3                          g_iProtect = 0;
1047   3                      g_cFunc++;
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 18  

1048   3                              key_release();
1049   3                      return 0;
1050   3                      }
1051   2                      if(key_num == KEY_SURE)
1052   2                      {
1053   3                        
1054   3                         temp1 = IapReadByte(ZERO_ADD_REV_1);
1055   3                         temp2 = IapReadByte(ZERO_ADD_REV_2);
1056   3                         g_fZero_rev = (temp1*100+temp2)/100;
1057   3                         g_iProtect = 0;
1058   3                         g_fK1 = 1.0;
1059   3                         g_fZero =g_fZero_rev ;
1060   3                         Clean_Display(0,0,128,64,0);
1061   3      
1062   3                         if(display_Protect1(chinese3,10)==0)
1063   3                           {
1064   4                                 
1065   4                                 g_fK1 = k1;
1066   4                                 g_fZero = zero;
1067   4                               }
1068   3                               else
1069   3                               {
1070   4                                Dateeprom();
1071   4                               }
1072   3                         Clean_Display(0,0,128,64,0);
1073   3                         display_stringChinese(0,0,chinese);
1074   3                         if((g_fZero>(g_fZero_rev-0.01)&&g_fZero<(g_fZero_rev+0.01)) && g_fK1>0.99 && g_fK1<1.01 )
1075   3                     {
1076   4                       display_stringChinese(0,1,chinese1);
1077   4                     }
1078   3                     else
1079   3                     {
1080   4                       display_stringChinese(0,1,chinese2);
1081   4                     }        
1082   3                      }
1083   2      
1084   2      
1085   2                      key_delay();
1086   2                  if(return_Main())
1087   2                      {
1088   3                              return 0;
1089   3                      }
1090   2              //      disylay_mun(100,2,0,2);
1091   2              }
1092   1      }
1093          
1094          
1095          unsigned char display_uint()
1096          {
1097   1              unsigned char key_num;
1098   1              char uint1 ;
1099   1              char temp_uint1;
1100   1        code unsigned char* chinese[] ={font_15,font_16,font_00,font_00,font_00};       //单位
1101   1        code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};   //密码2
1102   1        code char arr0[] = {'m',59,'/','s',' ',' ','\0'};
1103   1        code char arr1[] = {'m',59,'/','m','i','n','\0'};
1104   1         uint1 = g_cUint;
1105   1         temp_uint1 = g_cUint;
1106   1              display_stringChinese(0,0,chinese);
1107   1               if(uint1 == 1)
1108   1                {
1109   2                        display_stringChar(3,1,arr1);
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 19  

1110   2                }
1111   1                 else
1112   1                {
1113   2                        display_stringChar(3,1,arr0);
1114   2                }
1115   1              while(1)
1116   1              {
1117   2                 if(g_cMaxOut ==0 || g_cMaxOut ==2)
1118   2                  read_Maxout();
1119   2                      key_num = key();
1120   2                      if(key_num == KEY_FUNC)
1121   2                      {
1122   3                          g_iProtect = 0;
1123   3                      g_cFunc++;
1124   3                              key_release();
1125   3                      return 0;
1126   3                      }
1127   2              if(key_num == KEY_ADD)
1128   2                       {
1129   3                          g_iProtect = 0;
1130   3                          uint1++;
1131   3                              if(uint1 == 2)
1132   3                                uint1 = 0;
1133   3                         if(uint1 == 1)
1134   3                         {
1135   4                           display_stringChar(3,1,arr1);
1136   4                         }
1137   3                         else
1138   3                         {
1139   4                           display_stringChar(3,1,arr0);
1140   4                         }
1141   3                       }
1142   2                       if(key_num == KEY_SUB)
1143   2                       {
1144   3                         g_iProtect = 0;
1145   3                         uint1--;
1146   3                         if(uint1 < 0)
1147   3                          uint1 = 1;
1148   3                              if(uint1 == 1)
1149   3                         {
1150   4                           display_stringChar(3,1,arr1);
1151   4                         }
1152   3                         else
1153   3                         {
1154   4                           display_stringChar(3,1,arr0);
1155   4                         }
1156   3                       }
1157   2      
1158   2                       if(key_num == KEY_SURE)
1159   2                         {
1160   3                             g_iProtect = 0;
1161   3                             g_cUint = uint1;
1162   3                                 Clean_Display(0,0,128,64,0);
1163   3                             if(display_Protect1(chinese2,10)==0)
1164   3                                   {
1165   4                                          g_cUint = temp_uint1;
1166   4                                              uint1 = g_cUint;
1167   4                                       }
1168   3                                       else
1169   3                                       {
1170   4                                         Dateeprom();
1171   4                                       }
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 20  

1172   3                             Clean_Display(0,0,128,64,0);
1173   3                             display_stringChinese(0,0,chinese);
1174   3                                 if(uint1 == 1)
1175   3                                 {
1176   4                                   display_stringChar(3,1,arr1);
1177   4                                 }
1178   3                                 else
1179   3                                 {
1180   4                                   display_stringChar(3,1,arr0);
1181   4                                 }
1182   3                         }
1183   2      
1184   2                      key_delay();
1185   2                  if(return_Main())
1186   2                      {
1187   3                              return 0;
1188   3                      }
1189   2              //      disylay_mun(100,2,0,2);
1190   2              }
1191   1      
1192   1      }
1193          
1194          unsigned char display_workchang()
1195          {
1196   1              unsigned char key_num;
1197   1              char workChange ;
1198   1              char temp_workChange;
1199   1        code unsigned char* chinese[] ={font_38,font_02,lei,xin,font_00};       //流量类型
1200   1        code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};   //密码2
1201   1        code unsigned char* chinese_isCh4[] ={gong,kuang,font_38,font_02,font_00};      //纯甲烷流量  此处改成工况
1202   1        code unsigned char* chinese_noCh4[] ={biao,kuang,font_38,font_02,font_00};      //混合流量  此处改成标况
1203   1         workChange = g_cWorkChange;
1204   1         temp_workChange = g_cWorkChange;
1205   1              display_stringChinese(0,0,chinese);
1206   1               if(workChange == 1)
1207   1                {
1208   2                   display_stringChinese(0,1,chinese_isCh4);
1209   2                }
1210   1                 else
1211   1                {
1212   2                        display_stringChinese(0,1,chinese_noCh4);
1213   2                }
1214   1              while(1)
1215   1              {
1216   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1217   2                  read_Maxout();
1218   2                      key_num = key();
1219   2                      if(key_num == KEY_FUNC)
1220   2                      {
1221   3                          g_iProtect = 0;
1222   3                      g_cFunc++;
1223   3                              key_release();
1224   3                      return 0;
1225   3                      }
1226   2              if(key_num == KEY_ADD)
1227   2                       {
1228   3                          g_iProtect = 0;
1229   3                          workChange++;
1230   3                              if(workChange == 2)
1231   3                                workChange = 0;
1232   3                         if(workChange == 1)
1233   3                         {
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 21  

1234   4                           display_stringChinese(0,1,chinese_isCh4);
1235   4                         }
1236   3                         else
1237   3                         {
1238   4                           display_stringChinese(0,1,chinese_noCh4);
1239   4                         }
1240   3                       }
1241   2                       if(key_num == KEY_SUB)
1242   2                       {
1243   3                         g_iProtect = 0;
1244   3                         workChange--;
1245   3                         if(workChange < 0)
1246   3                          {
1247   4                            workChange = 1;
1248   4                              }
1249   3                              if(workChange == 1)
1250   3                         {
1251   4                           display_stringChinese(0,1,chinese_isCh4);
1252   4                         }
1253   3                         else
1254   3                         {
1255   4                           display_stringChinese(0,1,chinese_noCh4);
1256   4                         }
1257   3                       }
1258   2      
1259   2                       if(key_num == KEY_SURE)
1260   2                         {
1261   3                             g_iProtect = 0;
1262   3                             g_cWorkChange = workChange;
1263   3                                 Clean_Display(0,0,128,64,0);
1264   3                             if(display_Protect1(chinese2,10)==0)
1265   3                                   {
1266   4                                          g_cWorkChange = temp_workChange;
1267   4                                              workChange = g_cWorkChange;
1268   4                                       }
1269   3                                       else
1270   3                                       {
1271   4                                         Dateeprom();
1272   4                                       }
1273   3                             Clean_Display(0,0,128,64,0);
1274   3                             display_stringChinese(0,0,chinese);
1275   3                                 if(workChange == 1)
1276   3                                 {
1277   4                                   display_stringChinese(0,1,chinese_isCh4);
1278   4                                 }
1279   3                                 else
1280   3                                 {
1281   4                                   display_stringChinese(0,1,chinese_noCh4);
1282   4                                 }
1283   3                         }
1284   2      
1285   2                      key_delay();
1286   2                  if(return_Main())
1287   2                      {
1288   3                              return 0;
1289   3                      }
1290   2              }
1291   1      
1292   1      }
1293          
1294          
1295          unsigned char display_MaxOut()
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 22  

1296          {
1297   1              unsigned char key_num;
1298   1              char maxout ;
1299   1              char temp_maxout;
1300   1              char flag = 0;
1301   1          unsigned char* chineseClear[] ={qing,font_03,font_00,font_00,font_00};        //清零选择
1302   1              code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};     //密码2
1303   1         code char arrOFF[] = {'O','F','F',' ','\0'};
1304   1         code char arrON[] =  {'O','N',' ',' ','\0'};
1305   1        // code char arrm3[] = {'m',59,'\0'};
1306   1       //  code char arr[] = {':','\0'};
1307   1      
1308   1         maxout = g_cMaxOut;
1309   1         temp_maxout = g_cMaxOut;
1310   1      
1311   1         mian2_chinese();
1312   1      
1313   1              while(1)
1314   1              {
1315   2                  if(maxout == 0 || maxout == 2)
1316   2                      {
1317   3                    read_Maxout();
1318   3                      }
1319   2                      if(0 == flag && g_iTimebase <= 5  )
1320   2                              {
1321   3                                          flag = 1;
1322   3                                              display_sum(g_fSum,5,1); //显示工况累积值
1323   3                                              display_sum(g_fSum_biao,5,2); //显示工况累积值
1324   3                                              display_sum(g_fSum_biao_ch4,5,3);
1325   3                                              //display_sum(12345678,6,3);
1326   3      
1327   3                              }
1328   2                              else if(g_iTimebase>5)
1329   2                              {
1330   3                                           flag = 0 ;
1331   3                              }                 
1332   2                      
1333   2                      key_num = key();
1334   2                      if(key_num == KEY_FUNC)
1335   2                      {
1336   3                          g_iProtect = 0;
1337   3                      g_cFunc++;
1338   3                              key_release();
1339   3                      return 0;
1340   3                      }
1341   2              if(key_num == KEY_ADD)
1342   2                       {
1343   3                          g_iProtect = 0;
1344   3                          maxout++;
1345   3                              if(maxout == 3)
1346   3                                maxout = 0;
1347   3                         if(maxout == 1)
1348   3                         {
1349   4                           display_stringChar(7,0,arrOFF);
1350   4                         }
1351   3                         else if(maxout == 0)
1352   3                         {
1353   4                           display_stringChar(7,0,arrON);
1354   4                         }
1355   3                         else
1356   3                         {
1357   4                           display_stringChinese(7,0,chineseClear);
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 23  

1358   4                         }
1359   3                       }
1360   2                       if(key_num == KEY_SUB)
1361   2                       {
1362   3                         g_iProtect = 0;
1363   3                         maxout--;
1364   3                         if(maxout < 0)
1365   3                          maxout = 2;
1366   3                              if(maxout == 1)
1367   3                         {
1368   4                           display_stringChar(7,0,arrOFF);
1369   4                         }
1370   3                         else if(maxout == 0)
1371   3                         {
1372   4                           display_stringChar(7,0,arrON);
1373   4                         }
1374   3                         else
1375   3                         {
1376   4                           display_stringChinese(7,0,chineseClear);
1377   4                         }
1378   3      
1379   3                       }
1380   2      
1381   2                       if(key_num == KEY_SURE)
1382   2                         {
1383   3                             g_iProtect = 0;
1384   3                             g_cMaxOut = maxout;
1385   3                                 Clean_Display(0,0,128,64,0);
1386   3                             if(display_Protect1(chinese2,10)==0)
1387   3                                   {
1388   4                                          g_cMaxOut = temp_maxout;
1389   4                                              maxout = g_cMaxOut;
1390   4                                       }
1391   3                                       else
1392   3                                       {
1393   4                                         if(maxout == 2)
1394   4                                           {
1395   5                                                  g_fSum = 0.0;
1396   5                                                      g_fSum_biao = 0.0;
1397   5                                                      g_fSum_biao_ch4 = 0.0;
1398   5                                               }
1399   4                                         Dateeprom();
1400   4                                       }
1401   3                             Clean_Display(0,0,128,64,0);
1402   3                            mian2_chinese();
1403   3                                display_sum(g_fSum,5,1); //显示工况累积值
1404   3                                display_sum(g_fSum_biao,5,2); //显示工况累积值
1405   3                                display_sum(g_fSum_biao_ch4,5,3); 
1406   3                         }
1407   2      
1408   2                      key_delay();
1409   2                  if(return_Main())
1410   2                      {
1411   3                              return 0;
1412   3                      }
1413   2              }
1414   1      
1415   1      }  
1416          unsigned char display_Range()
1417          {
1418   1              unsigned char key_num;
1419   1              unsigned int range,rangeMin,temp_range,temp_rangeMin;
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 24  

1420   1      
1421   1        code unsigned char* chinese[] ={font_02,font_21,font_00,font_00,font_00};       //量程
1422   1        code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};   //密码2
1423   1        code char arr0[] = {'m',59,'/','s',' ',' ','\0'};
1424   1        code char arr1[] = {'m',59,'/','m','i','n','\0'};
1425   1           range = g_iRange;
1426   1               temp_range = range;
1427   1               rangeMin = g_iRangeMin;
1428   1               temp_rangeMin = rangeMin;
1429   1              display_stringChinese(0,0,chinese);
1430   1              if(g_cUint == 0)
1431   1              {
1432   2                display_stringChar(5,1,arr0);
1433   2                disylay_mun(range,0,0,1);
1434   2              }
1435   1              else
1436   1              {
1437   2                display_stringChar(5,1,arr1);
1438   2                disylay_mun(rangeMin,0,0,1);
1439   2              } 
1440   1              while(1)
1441   1              {
1442   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1443   2                  read_Maxout();
1444   2                      key_num = key();
1445   2                      if(key_num == KEY_FUNC)
1446   2                      {
1447   3                          g_iProtect = 0;
1448   3                      g_cFunc++;
1449   3                              key_release();
1450   3                      return 0;
1451   3                      }
1452   2      
1453   2                      if(key_num == KEY_ADD)
1454   2                      {
1455   3                          g_iProtect = 0;
1456   3                      if(g_cUint == 0)
1457   3                                {
1458   4                                  range++;
1459   4                                      if(range > 10)
1460   4                                       {
1461   5                                        range = 10;
1462   5                                       }
1463   4                                       disylay_mun(range,0,0,1);
1464   4                                }
1465   3                                else
1466   3                                {
1467   4                                  rangeMin = rangeMin+5;
1468   4                                      if(rangeMin > 1000)
1469   4                                         rangeMin = 1000;
1470   4                                      disylay_mun(rangeMin,0,0,1);
1471   4                                }
1472   3                      }
1473   2      
1474   2                      if(key_num == KEY_SUB)
1475   2                      {
1476   3                          g_iProtect = 0;
1477   3                      if(g_cUint == 0)
1478   3                                {
1479   4                                  range--;
1480   4                                      if(range == 0)
1481   4                                       {
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 25  

1482   5                                        range = 1;
1483   5                                       }
1484   4                                       disylay_mun(range,0,0,1);
1485   4                                }
1486   3                                else
1487   3                                {
1488   4                                  rangeMin = rangeMin-5;
1489   4                                      if(rangeMin == 0)
1490   4                                         rangeMin = 5;
1491   4                                      disylay_mun(rangeMin,0,0,1);
1492   4                                }
1493   3                      }
1494   2      
1495   2                      if(key_num == KEY_SURE)
1496   2                        {
1497   3                             g_iProtect = 0;
1498   3                             g_iRange =range;
1499   3                         g_iRangeMin = rangeMin ;
1500   3                                 Clean_Display(0,0,128,64,0);
1501   3                             if(display_Protect1(chinese2,10)==0)
1502   3                                   {
1503   4                                         g_iRange = temp_range;
1504   4                                         g_iRangeMin = temp_rangeMin;
1505   4                                         range = g_iRange;
1506   4                                         rangeMin = g_iRangeMin;
1507   4                                       }
1508   3                                       else
1509   3                                       {
1510   4                                         Dateeprom();
1511   4                                       }
1512   3                             Clean_Display(0,0,128,64,0);
1513   3                             display_stringChinese(0,0,chinese);
1514   3                                      if(g_cUint == 0)
1515   3                                      {
1516   4                                        display_stringChar(5,1,arr0);
1517   4                                        disylay_mun(range,0,0,1);
1518   4                                      }
1519   3                                      else
1520   3                                      {
1521   4                                        display_stringChar(5,1,arr1);
1522   4                                        disylay_mun(rangeMin,0,0,1);
1523   4                                      } 
1524   3                        }
1525   2      
1526   2                      key_delay();
1527   2                  if(return_Main())
1528   2                      {
1529   3                              return 0;
1530   3                      }
1531   2              //      disylay_mun(100,2,0,2);
1532   2              }
1533   1      }
1534          
1535          unsigned char display_Protect1(unsigned char ** chinese,char num)
1536          {
1537   1              unsigned char key_num;
1538   1      //      unsigned char i;
1539   1          
1540   1         unsigned char password=0;
1541   1       //  unsigned char* chinese[] ={font_22,font_23,yi,font_00,font_00};      //密码1
1542   1         code char arrOK[] = {'O','K',' ',' ',' ','\0'};
1543   1         code char arrNO[] = {'N','O',' ',' ',' ','\0'};
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 26  

1544   1         code char arr[] = {'e','r','r','\0'};
1545   1              display_stringChinese(0,0,chinese);
1546   1              
1547   1        //    display_stringChar(6,1,arr); 
1548   1          disylay_mun(password,0,0,1);
1549   1              key_release();
1550   1              while(1)
1551   1              {
1552   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1553   2                  read_Maxout();
1554   2                      key_num = key();
1555   2      //              if(key_num == KEY_FUNC)
1556   2      //              {
1557   2      //                      key_release();
1558   2      //              return 0;
1559   2      //              }                                                                                                                                                                               `
1560   2                      if(key_num == KEY_ADD)
1561   2                      {
1562   3                         g_iProtect = 0;
1563   3                         password++;
1564   3                         disylay_mun(password,0,0,1);
1565   3                        
1566   3                      }
1567   2                      if(key_num == KEY_SUB)
1568   2                      {
1569   3                         g_iProtect = 0;
1570   3                         password--;
1571   3                         disylay_mun(password,0,0,1);
1572   3                        
1573   3                      }
1574   2                      if(key_num == KEY_SURE)
1575   2                      {
1576   3                         key_release();
1577   3                         g_iProtect = 0;
1578   3                         if(password == num)
1579   3                           {
1580   4                                      display_stringChar(0,1,arrOK);
1581   4                                      delay(1000);
1582   4                                      g_cFunc = 1;
1583   4                                      return 1;
1584   4                               }
1585   3                               else
1586   3                               {
1587   4                                      display_stringChar(0,1,arrNO);
1588   4                                      delay(1000);
1589   4                                      disylay_mun(password,0,0,1);
1590   4                                      if(g_cFunc == 13) 
1591   4                                        {
1592   5                                           g_cSecrit_Num++;
1593   5                                                 if(g_cSecrit_Num == 5)
1594   5                                                     g_cSecrit_Num = 4;
1595   5                                               Dateeprom();
1596   5                                               if(g_cSecrit_Num>=3)
1597   5                                                {
1598   6                                                  Clean_Display(0,0,128,64,0);
1599   6                                                       display_stringChar(6,1,arr);
1600   6                                                              while(1)
1601   6                                                      {
1602   7                                                      }
1603   6                                                }
1604   5                                        }
1605   4                               }
C51 COMPILER V9.01   DISPLAY                                                               05/24/2015 16:02:55 PAGE 27  

1606   3                      }
1607   2                      if(key_num == KEY_FUNC)
1608   2                      {
1609   3                          g_iProtect = 0;
1610   3                          key_release();
1611   3                              return 0;
1612   3                      }
1613   2                         key_delay();
1614   2                              if(return_Main())
1615   2                               {
1616   3                                  return 0;
1617   3                               }
1618   2              //      disylay_mun(100,2,0,2);
1619   2              }
1620   1      }
1621          
1622          
1623          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8187    ----
   CONSTANT SIZE    =    679    ----
   XDATA SIZE       =     13     328
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
