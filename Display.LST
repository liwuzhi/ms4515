C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN Display.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Display.c COMPACT OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "display.h"
   2          #include "ziku.h"
   3          #include "key.h"
   4          #include "storage.h"
   5          #include "spd6000.h"
   6          #include "MS4525.h"
   7          #include "pwm.h"
   8          #include "CH4.h"
   9          #include "eeprom.h"
  10          
  11          #define POINT_0 0
  12          #define POINT_1 1
  13          #define POINT_2 2
  14          #define POINT_3 3
  15          
  16          #define ZERO_ADD_REV_1 0x6fe1
  17          #define ZERO_ADD_REV_2 0x6fe2
  18          
  19          #define READ_TIME 10
  20          
  21          sbit  OUT2  = P3^7;
  22          
  23          
  24          
  25          void delay( int x)
  26          {
  27   1          int y,z;
  28   1         for(y=x;y>0;y--)
  29   1          {
  30   2                 for(z=100;z>0;z--)
  31   2                  {
  32   3                      }
  33   2              }
  34   1      }
  35          
  36          void key_delay()
  37          {
  38   1         static char num;
  39   1         if(key() != 0)
  40   1           {
  41   2                  num++;
  42   2                      if(num > 20)
  43   2                        {
  44   3                          num = 11;
  45   3                        }
  46   2                 if(num >10)
  47   2                   {
  48   3                         delay(1);
  49   3                       }
  50   2                       else
  51   2                       {
  52   3                         delay(300);
  53   3                       }
  54   2               }
  55   1               else
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 2   

  56   1               {
  57   2                 num =0;
  58   2               }
  59   1         if(num >10)
  60   1           {
  61   2                 delay(10);
  62   2               }
  63   1               else
  64   1               {
  65   2                 delay(1000);
  66   2               }
  67   1      }
  68          
  69          unsigned char return_Main()
  70          {
  71   1                  if(g_iProtect > 900)
  72   1                                 {
  73   2                                    g_cFunc = 0;
  74   2                                    return 1;
  75   2                                 }
  76   1                                 else
  77   1                                 {
  78   2                                    return 0;
  79   2                                 }
  80   1      }
  81          void disylay_mun(unsigned int num,char point,char start_x,char start_y)
  82          {
  83   1        unsigned char temp_num[5];
  84   1        unsigned char temp[6]={0,0,0,0,0,0};
  85   1        unsigned char i=0,j=0;
  86   1        temp_num[0] = num/10000+'0';
  87   1        temp_num[1] = num%10000/1000+'0';
  88   1        temp_num[2] = num%1000/100+'0';
  89   1        temp_num[3] = num%100/10+'0';
  90   1        temp_num[4] = num%10+'0';
  91   1         temp[5-point] = '.';
  92   1        for(i=0;i<6;i++)
  93   1        {
  94   2           if(0 == temp[i])
  95   2               {
  96   3                  temp[i] = temp_num[j];
  97   3                      j++;
  98   3               }
  99   2        }
 100   1        for(i=0;i<4-point;i++)
 101   1               {
 102   2                 if(temp[i] == '0')
 103   2                   {
 104   3                         temp[i] = ' ';
 105   3                       }
 106   2                       else
 107   2                       {
 108   3                         break;
 109   3                       }
 110   2               }
 111   1          if(point>0)
 112   1              {
 113   2                 Display_Onechar(start_x*8,start_y*2,temp[0],0);
 114   2             Display_Onechar((start_x+1)*8,start_y*2,temp[1],0);
 115   2                 Display_Onechar((start_x+2)*8,start_y*2,temp[2],0);
 116   2                 Display_Onechar((start_x+3)*8,start_y*2,temp[3],0);
 117   2                 Display_Onechar((start_x+4)*8,start_y*2,temp[4],0);
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 3   

 118   2                 Display_Onechar((start_x+5)*8,start_y*2,temp[5],0);
 119   2              }
 120   1              else
 121   1              {
 122   2                 Display_Onechar(start_x*8,start_y*2,temp[0],0);
 123   2                 Display_Onechar((start_x+1)*8,start_y*2,temp[1],0);
 124   2                 Display_Onechar((start_x+2)*8,start_y*2,temp[2],0);
 125   2                 Display_Onechar((start_x+3)*8,start_y*2,temp[3],0);
 126   2                 Display_Onechar((start_x+4)*8,start_y*2,temp[4],0);
 127   2              }
 128   1      }
 129          
 130          void display_stringChar(unsigned char start_x,unsigned char start_y,char* s)
 131          {
 132   1            unsigned char i=0;
 133   1                while(*s != '\0')
 134   1                {
 135   2                   Display_Onechar((start_x+i)*8,start_y*2,*s,0);
 136   2                       i++;
 137   2                       s++;
 138   2                }       
 139   1      }
 140          
 141          void display_stringChinese(unsigned char start_x,unsigned char start_y,unsigned char** s)
 142          {
 143   1        unsigned char i=0;
 144   1        for(i=0;i<5;i++)
 145   1        {
 146   2         Display_Graphic(start_x*8+i*16,start_y*2,16,16,*s,0);
 147   2         s++;
 148   2         }
 149   1      }
 150          
 151          void display_sum(long sum,char start_x,char start_y)
 152          {
 153   1         unsigned char temp[9] = {0,0,0,0,0,0,0,0};
 154   1         char i;
 155   1         if(sum>999999999)
 156   1         {
 157   2           sum = 999999999;
 158   2         }
 159   1         temp[0] = sum/100000000L+'0';
 160   1         temp[1] = sum%100000000L/10000000L+'0';
 161   1         temp[2] = sum%10000000L/1000000L+'0';
 162   1         temp[3] = sum%1000000L/100000L+'0';
 163   1         temp[4] = sum%100000L/10000L+'0';
 164   1         temp[5] = sum%10000L/1000L+'0';
 165   1         temp[6] = sum%1000L/100L+'0';
 166   1         temp[7] = sum%100L/10L+'0';
 167   1         temp[8] = sum%10L+'0';
 168   1      
 169   1         for(i=0;i<8;i++)
 170   1               {
 171   2                 if(temp[i] == '0')
 172   2                   {
 173   3                         temp[i] = ' ';
 174   3                       }
 175   2                       else
 176   2                       {
 177   3                         break;
 178   3                       }
 179   2               }
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 4   

 180   1         for(i=0;i<9;i++)
 181   1         {
 182   2            Display_Onechar((start_x+i)*8,start_y*2,temp[i],0);
 183   2         }
 184   1      }
 185           
 186          void read_senser(float* p_flux,float* p_pase,float ch4,float* tmpter)
 187          {
 188   1              float ch4_temp;
 189   1                      float temp = 0;
 190   1              //      static int num = 0;
 191   1                         ch4_temp = ch4;
 192   1                         if(ch4_temp<0.001)
 193   1                            {
 194   2                                   ch4_temp= 0.0;
 195   2                                }
 196   1                 *p_pase = date_Smooth_4525(tmpter); //读取绝压值
 197   1                         temp = Wid_Speed();
 198   1                        // if(temp>0.001)
 199   1                         //  {
 200   1                      //         num++;
 201   1                      //       }
 202   1                         //disylay_mun(temp*100,POINT_2,6,1);
 203   1                         //disylay_mun(num,POINT_0,6,2);
 204   1                     if(g_cUint == 0)
 205   1                         {
 206   2                          if(g_cWorkChange == 1)      //工况
 207   2                              {
 208   3                            *p_flux =  temp*g_iArea/10000;
 209   3                              }
 210   2                              else  //标况
 211   2                              {
 212   3                               *p_flux =  temp*g_iArea/10000*(*p_pase/101.325)*(293/(273+*tmpter));
 213   3                              }
 214   2                              if(*p_flux>g_iRange)
 215   2                                {                                        
 216   3                                   *p_flux = g_iRange;
 217   3                                }
 218   2                        }
 219   1                        else
 220   1                        {
 221   2                          if(g_cWorkChange == 1)
 222   2                              {
 223   3                            *p_flux =  temp*g_iArea/10000*60;
 224   3                              }
 225   2                              else
 226   2                              {
 227   3                                *p_flux =  temp*g_iArea/10000*60*(*p_pase/101.325)*(293/(273+*tmpter));
 228   3                              }
 229   2                          if(*p_flux>g_iRangeMin)
 230   2                                {
 231   3                                   *p_flux = g_iRangeMin;
 232   3                                } 
 233   2                       }
 234   1      }
 235             
 236          
 237          
 238          void read_Maxout()
 239          {
 240   1         float p_flux;
 241   1         float p_pase;
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 5   

 242   1         float ch4;
 243   1         static char flag=0;
 244   1         static char flag1=0;
 245   1         float temper;
 246   1      
 247   1         if(g_iTime < 10 && flag1 ==0)        //每一小时保存一次
 248   1                      {
 249   2                        if(g_cMaxOut == 0 || g_cMaxOut == 2)
 250   2                         {
 251   3                          Dateeprom();
 252   3                         }
 253   2                         flag1 = 1;
 254   2                      }
 255   1                      else if(g_iTime > 10)
 256   1                       {
 257   2                         flag1 = 0;
 258   2                       }
 259   1      
 260   1        // if(g_iTimebase <= 10 && flag == 0 )
 261   1         if(g_iTime%57 < 20 && flag ==0 )     //每一分钟计算一次
 262   1         {
 263   2              flag = 1;
 264   2              ch4 = read_ch4();
 265   2                      if(ch4 < 0.001)
 266   2                        {
 267   3                           ch4 =0.0;
 268   3                        }
 269   2                 p_pase = date_Smooth_4525(&temper); //读取绝压值
 270   2                        p_flux = Wid_Speed()*g_iArea/10000;
 271   2                     
 272   2                       if(g_cUint == 0)
 273   2                        {
 274   3                               g_fSum = g_fSum + p_flux;
 275   3                               g_fSum_biao = g_fSum_biao +  p_flux*(p_pase/101.325)*(293/(273+temper));
 276   3                               g_fSum_biao_ch4 = g_fSum_biao_ch4 + p_flux*(p_pase/101.325)*(293/(273+temper))*ch4/100;
 277   3                        }
 278   2                        else
 279   2                        {
 280   3                            g_fSum = g_fSum + p_flux*60 ;
 281   3                                g_fSum_biao = g_fSum_biao + p_flux*60*(p_pase/101.325)*(293/(273+temper));
 282   3                                g_fSum_biao_ch4 = g_fSum_biao_ch4 + p_flux*60*(p_pase/101.325)*(293/(273+temper))*ch4/100;
 283   3                        }
 284   2              }
 285   1              else if(g_iTime%57 > 20)
 286   1              {
 287   2                 flag = 0;
 288   2              }
 289   1      }       
 290          /*
 291            显示压力界面
 292          */
 293          unsigned char display_Preassure()
 294          {
 295   1              unsigned char key_num;
 296   1              unsigned int preassure;
 297   1          code unsigned char* chinese[] ={font_13,font_14,font_00,font_00,font_00};
 298   1          code char arr[] = {'p','a','\0'};
 299   1      
 300   1          preassure = date_Smooth();
 301   1              display_stringChinese(0,0,chinese);
 302   1              display_stringChar(6,1,arr);
 303   1              disylay_mun(preassure,0,0,1); 
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 6   

 304   1      
 305   1              while(1)
 306   1              {
 307   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 308   2                  read_Maxout();
 309   2                      key_num = key();
 310   2                      if(key_num == KEY_FUNC)
 311   2                      {
 312   3                      g_cFunc++;
 313   3                              key_release();
 314   3                      return 0;
 315   3                      }
 316   2                      #ifdef _DEBUG_
                              preassure = key_AddSub(preassure,1,0,1,10000);
                              date.pressure = ((float)preassure)/10; 
                              #else
 320   2                      if((g_iTimebase%READ_TIME) == 0)
 321   2                        {
 322   3                         preassure = date_Smooth();
 323   3                         disylay_mun(preassure,0,0,1);
 324   3                        }
 325   2                      #endif
 326   2                      
 327   2                      key_delay();
 328   2                  if(return_Main())
 329   2                      {
 330   3                              return 0;
 331   3                      }
 332   2              }
 333   1            return 0;
 334   1      }
 335          
 336          unsigned char display_Area()
 337          {
 338   1              unsigned char key_num;
 339   1              unsigned int area;
 340   1              unsigned int temp_area;
 341   1         code unsigned char* chinese[] ={font_11,font_12,font_07,font_00,font_00,font_00};    //截面积
 342   1         code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};          //密码2
 343   1         code char arr[] = {'c','m',60,'\0'};
 344   1             area = g_iArea;
 345   1                 temp_area = area;
 346   1              display_stringChinese(0,0,chinese);
 347   1              display_stringChar(5,1,arr);
 348   1              disylay_mun(area,0,0,1); 
 349   1              while(1)
 350   1              {
 351   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 352   2                  read_Maxout();
 353   2                      key_num = key();
 354   2                      if(key_num == KEY_FUNC)
 355   2                      {
 356   3                      g_cFunc++;
 357   3                              key_release();
 358   3                      return 0;
 359   3                      }
 360   2              area = key_AddSub(area,0,0,1,10000);
 361   2                      if(key_num == KEY_SURE)
 362   2                      {
 363   3                         g_iProtect = 0;
 364   3                         g_iArea = area;
 365   3                         Clean_Display(0,0,128,64,0);
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 7   

 366   3                         if(display_Protect1(chinese2,10) == 0)
 367   3                           {
 368   4                                  g_iArea = temp_area;
 369   4                                      area = g_iArea;
 370   4                               }
 371   3                               else
 372   3                               {
 373   4                                 Dateeprom();
 374   4                               }
 375   3                         Clean_Display(0,0,128,64,0);
 376   3                         display_stringChinese(0,0,chinese);
 377   3                         display_stringChar(5,1,arr);
 378   3                         disylay_mun(area,0,0,1);
 379   3                      }
 380   2                      key_delay();
 381   2                  if(return_Main())
 382   2                      {
 383   3                              return 0;
 384   3                      }
 385   2              //      disylay_mun(100,2,0,2);
 386   2              }
 387   1      }
 388          
 389          void mian1_chinese()
 390          {
 391   1        unsigned char* chineseWork[] ={gong,kuang,font_00,font_00,font_00};     //工况
 392   1         unsigned char* chineseStandar[] ={biao,kuang,font_00,font_00,font_00}; //标况
 393   1        //code unsigned char* chineseFlux[] ={font_38,font_02,font_37,font_00,font_00};        //流量  此处应改成工况
 394   1        code unsigned char* chinesePase[] = {font_13,font_14,font_37,font_00,font_00}; //压力
 395   1        code unsigned char* chineseCH4[] = {jia,wan,font_37,font_00,font_00}; //甲烷
 396   1        //code unsigned char*  chineseMin[] = {font_32,font_33,font_34,font_35,font_36};//流量变送器
 397   1        //unsigned char * code chineseisch4[] = {chun,font_02,font_37,font_00,font_00};        //纯量  此处应改成标况
 398   1        unsigned char *code chineseTmp[] = {font_41,font_42,font_00,font_00,font_00};  //温度
 399   1      
 400   1      //   code char arrm3[] = {'m',59,'\0'};
 401   1      
 402   1         code char arr[] = {':','\0'};
 403   1         code char arrS[] = {'m',59,'/','s','\0'};     //m3/s
 404   1         code char arrMin[] = {'m',59,'/','m','i','n','\0'}; //m3/min
 405   1         code char arrKPa[] = {'K','P','a','\0'};
 406   1       //  code char arrERR[] = {' ','-','-',' ',' ',' ',' ','\0'};
 407   1         code char arrch4[]   = {'%','\0'};
 408   1         code char arrTmper[] = {34,'C','\0'};
 409   1               
 410   1          if(g_cWorkChange == 1)
 411   1              { 
 412   2                display_stringChinese(0,0,chineseWork);        //显示中文流量
 413   2              }
 414   1              else
 415   1              {
 416   2                display_stringChinese(0,0,chineseStandar);    
 417   2              }
 418   1              /*显示流量单位*/
 419   1                if(g_cUint == 0)
 420   1                {
 421   2                      display_stringChar(12,0,arrS);
 422   2                }
 423   1                else
 424   1                {
 425   2                  display_stringChar(10,0,arrMin);
 426   2                }
 427   1      
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 8   

 428   1              display_stringChinese(0,1,chinesePase);  //显示中文压力
 429   1              display_stringChar(13,1,arrKPa);         //显示绝压单位 
 430   1      
 431   1              display_stringChinese(0,2,chineseCH4);  //显示甲烷中文两个字
 432   1              display_stringChar(15,2,arrch4);           //显示甲烷中的%
 433   1              //display_stringChar(5,2,arrERR);                  //显示甲烷中的--
 434   1      
 435   1              display_stringChinese(0,3,chineseTmp);//显示温度字样
 436   1              display_stringChar(4,3,arr);
 437   1              display_stringChar(14,3,arrTmper);
 438   1      }
 439          
 440          void mian1_num(char i)
 441          {
 442   1         float pase;
 443   1         float flux;
 444   1         float ch4;
 445   1         float tmper;
 446   1         static float flux_sum =0.0;
 447   1         static float flux_sum_old =0.0;
 448   1         static char flux_num_1 = 0;
 449   1         static char flux_num_2 = 0;
 450   1        // static char first_flag = 1;
 451   1         code char arrERR[] = {' ','-','-',' ',' ',' ',' ','\0'};
 452   1         code char arr[] = {':','\0'};
 453   1      
 454   1                              ch4= read_ch4();
 455   1                                          read_senser(&flux,&pase,ch4,&tmper);
 456   1                                      disylay_mun(tmper*10,POINT_1,8,3);
 457   1                                                      
 458   1                                                                               
 459   1                                         if(pase<1.0)
 460   1                                         {
 461   2                                            display_stringChar(5,1,arrERR);   //显示--
 462   2                                                CR = 0;                         //PCA timer start run
 463   2                                    EPCAI = 0;
 464   2                                                OUT2 = 1;
 465   2                                         }
 466   1                                         else
 467   1                                         {
 468   2                                        disylay_mun(pase*10,POINT_1,7,1);      //显示绝压的数据
 469   2                                            CR = 1;                         //PCA timer start run
 470   2                                    EPCAI = 1;
 471   2                                           pca_set2(pase);//设置绝压的输出脉冲
 472   2                                         }
 473   1                                         
 474   1                                         /*设置甲烷的数据*/
 475   1                                         if(ch4 >= 0.0 && ch4 < 100.001)
 476   1                                              {
 477   2                                                  disylay_mun(ch4*10,POINT_1,9,2);    //显示甲烷的百分比
 478   2                                              }
 479   1                                              else
 480   1                                              {
 481   2                                                      display_stringChar(5,2,arrERR); //显示--
 482   2                                              }
 483   1                                        if(i == 0)
 484   1                                         {
 485   2                          flux_num_1++;
 486   2                                          flux_sum =flux_sum + flux;
 487   2                                         }
 488   1                                        if(10 == flux_num_1 || i == 1)
 489   1                                              {
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 9   

 490   2                                               
 491   2                                               if(i == 1)
 492   2                                               {
 493   3                                                  flux = flux_sum_old ;
 494   3                                               }
 495   2                                               else
 496   2                                               {
 497   3                                                flux_num_1 = 0;
 498   3                                                flux = flux_sum/10;
 499   3                                                flux_sum_old = flux;
 500   3                                                flux_sum = 0.0;
 501   3                                               }
 502   2                                               flux_num_2++;
 503   2                                               if(flux_num_2 == 4 || i == 1)
 504   2                                               {
 505   3                                                  i = 0;
 506   3                                                  flux_num_2=0;
 507   3                                               if(g_cUint == 0)         //在秒单位下的流量显示
 508   3                                                 {
 509   4                                                  disylay_mun(flux*100,POINT_2,6,0);
 510   4                                                  g_cOut1[0] = (65536-500000/(200+800.0/g_iRange*((float)flux))+3)/256; 
 511   4                                                  g_cOut1[1] = (65536-500000/(int)(200+800.0/g_iRange*(float)flux)+3)%256;
 512   4                                                 }
 513   3                                                 else
 514   3                                                 {
 515   4                                               if(flux>g_iRangeMin)
 516   4                                                        {
 517   5                                                           flux = g_iRangeMin;
 518   5                                                        }
 519   4                                                         if(flux<100)
 520   4                                                          {
 521   5                                                           disylay_mun(flux*100,POINT_2,4,0);
 522   5                                                               display_stringChar(4,0,arr);
 523   5                                                              }
 524   4                                                              else
 525   4                                                              {
 526   5                                                               if(flux>999.9)
 527   5                                                                 {
 528   6                                                                   flux = 999.9;
 529   6                                                                 }
 530   5                                                                disylay_mun(flux*10,POINT_1,4,0);
 531   5                                                                display_stringChar(4,0,arr);
 532   5                                                              }
 533   4                                                              g_cOut1[0] = (65536-500000/(200+800.0/g_iRangeMin*flux)+3)/256;  
 534   4                                                      g_cOut1[1] = (unsigned int)(65536-500000/(200+800.0/g_iRangeMin*flux)+3)%256;
 535   4                                                 }
 536   3                                                }
 537   2                                                      
 538   2                                      }
 539   1      
 540   1      }
 541          
 542          void mian2_chinese()
 543          {
 544   1      
 545   1         unsigned char* chinese[] ={zong,font_02,font_00,font_00,font_00};      //总量
 546   1         unsigned char* chineseWork[] ={gong,kuang,font_00,font_00,font_00};    //工况
 547   1         unsigned char* chineseStandar[] ={biao,kuang,font_00,font_00,font_00}; //标况
 548   1         unsigned char* chineseStandar_cun[] ={biao,chun,font_00,font_00,font_00}; //  标纯
 549   1         unsigned char* chineseClear[] ={qing,font_03,font_00,font_00,font_00};         //清零选择
 550   1         code char arrOFF[] = {'O','F','F',' ','\0'};
 551   1         code char arrON[] =  {'O','N',' ',' ','\0'};
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 10  

 552   1         code char arrm3[] = {'m',59,'\0'};
 553   1         code char arr[] = {':','\0'};
 554   1            
 555   1              Clean_Display(0,0,128,64,0);  
 556   1                      display_stringChinese(0,0,chinese);     //总量
 557   1                      display_stringChar(4,0,arr); //总量后面的：                     
 558   1                      if(g_cMaxOut == 1)
 559   1                       {
 560   2                           display_stringChar(7,0,arrOFF);
 561   2                       }
 562   1                      else if(g_cMaxOut == 0)
 563   1                       {
 564   2                               display_stringChar(7,0,arrON);
 565   2                       }
 566   1                  else
 567   1                       {
 568   2                               display_stringChinese(7,0,chineseClear);
 569   2                       }
 570   1                       /*显示工况和其单位*/
 571   1                      display_stringChinese(0,1,chineseWork);
 572   1              display_stringChar(14,1,arrm3);
 573   1              display_stringChar(4,1,arr);
 574   1      
 575   1                      /*显示标况和其单位*/
 576   1                      display_stringChinese(0,2,chineseStandar);
 577   1              display_stringChar(14,2,arrm3);
 578   1              display_stringChar(4,2,arr);
 579   1      
 580   1                      /*显示纯标和其单位*/
 581   1                      display_stringChinese(0,3,chineseStandar_cun);
 582   1              display_stringChar(14,3,arrm3);
 583   1                      display_stringChar(4,3,arr);
 584   1      }
 585          
 586          
 587          unsigned char display_Main()
 588          {
 589   1         unsigned char key_num;
 590   1         char flag=0;
 591   1         char flag_ret1 = 1;
 592   1         char flag_ret2 = 1;
 593   1         mian1_chinese();
 594   1         mian1_num(1);
 595   1         
 596   1              while(1)
 597   1              {   
 598   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 599   2                      {
 600   3                              read_Maxout();
 601   3                      }
 602   2                      key_num = key();        //检查按键
 603   2                                      if(key_num == KEY_FUNC)
 604   2                                      {
 605   3                                         if(g_iProtect>=900)   //在第一次按下时跳转到密码一界面，不然跳转跳转到正常的下一个界面
 606   3                                         {
 607   4                                               g_cFunc = 15;
 608   4                                         }
 609   3                                         else
 610   3                                         {
 611   4                                       g_cFunc++;
 612   4                                         }
 613   3                                              key_release();  //按键释放
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 11  

 614   3                                      return 0;
 615   3                                      }
 616   2                  if(g_iTime%30 < 20 )         //在前20s显示第一种界面
 617   2                      {
 618   3                              if(flag_ret1 == 1)
 619   3                                        {
 620   4                                          Clean_Display(0,0,128,64,0);
 621   4                                              mian1_chinese();
 622   4                                              mian1_num(1);
 623   4                                        }
 624   3                                       flag_ret1 = 0;
 625   3                                       flag_ret2 = 1;
 626   3      
 627   3                                  
 628   3                                      
 629   3                                         
 630   3                                      /*读取绝压和差压的传感器并显示*/
 631   3                                      // if(flag == 0 && (g_iTimebase <= 5 || (g_iTimebase >=10 && g_iTimebase<=15)) )
 632   3                                      if(0 == flag && g_iTimebase <= 5  )
 633   3                                       {
 634   4                                          flag = 1;
 635   4                                              mian1_num(0);
 636   4                                       }
 637   3                                       else if(g_iTimebase>5)
 638   3                                        {
 639   4                                           flag = 0 ;
 640   4                                        }
 641   3                      }
 642   2                      else
 643   2                      {
 644   3                        if(flag_ret2 == 1)
 645   3                              {
 646   4                                Clean_Display(0,0,128,64,0);
 647   4                        mian2_chinese();                                              
 648   4                              }
 649   3                              flag_ret1 = 1;
 650   3                              flag_ret2 = 0;
 651   3                              if(0 == flag && g_iTimebase <= 5  )
 652   3                              {
 653   4                                          flag = 1;
 654   4                                              display_sum(g_fSum,5,1); //显示工况累积值
 655   4                                              display_sum(g_fSum_biao,5,2); //显示工况累积值
 656   4                                              display_sum(g_fSum_biao_ch4,5,3);
 657   4                                              //display_sum(12345678,6,3);
 658   4      
 659   4                              }
 660   3                              else if(g_iTimebase>5)
 661   3                              {
 662   4                                           flag = 0 ;
 663   4                              }                 
 664   3                      }
 665   2              }
 666   1      }
 667          
 668          unsigned char display_WindSpeed()
 669          {
 670   1              unsigned char key_num;
 671   1              float windSpeed;
 672   1              unsigned int play;
 673   1          code unsigned char* chinese[] ={font_38,font_04,font_00,font_00,font_00};  //流速
 674   1          code char arr[] = {'m','/','s','\0'};
 675   1      
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 12  

 676   1              display_stringChinese(0,0,chinese);
 677   1              display_stringChar(6,1,arr);
 678   1              windSpeed = Wid_Speed();
 679   1              play = windSpeed*10;
 680   1              disylay_mun(play,1,0,1); 
 681   1      
 682   1              while(1)
 683   1              {
 684   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 685   2                  read_Maxout();
 686   2                      key_num = key();
 687   2                      if(key_num == KEY_FUNC)
 688   2                      {
 689   3                      g_cFunc++;
 690   3                              key_release();
 691   3                      return 0;
 692   3                      }
 693   2      
 694   2                  if((g_iTimebase%READ_TIME) == 0)
 695   2                       {
 696   3                          windSpeed = Wid_Speed();
 697   3                              play =windSpeed*10;
 698   3                              disylay_mun(play,POINT_1,0,1);
 699   3                       }
 700   2                      key_delay();
 701   2                  if(return_Main())
 702   2                      {
 703   3                              return 0;
 704   3                      }
 705   2              }
 706   1      }
 707          
 708          unsigned char display_WindSpeedZero()
 709          {
 710   1          char i;
 711   1              char error;
 712   1              unsigned char key_num;
 713   1              float windSpeed;
 714   1          int pressure = 0;
 715   1              unsigned int temper;
 716   1              float pressure_sum = 0;
 717   1          int play;
 718   1          code unsigned char* chinese[] ={font_03,font_24,font_05,font_06,font_00};     //零点校准
 719   1              code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};     //密码2
 720   1          code char arr[] = {'m','/','s','\0'};
 721   1      
 722   1              display_stringChinese(0,0,chinese);
 723   1              display_stringChar(6,1,arr);
 724   1              windSpeed = Wid_Speed();
 725   1              play =  (int)(windSpeed*10);
 726   1              disylay_mun(play,1,0,1);  
 727   1              while(1)
 728   1              {
 729   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 730   2                  read_Maxout();
 731   2                      key_num = key();
 732   2                      if(key_num == KEY_FUNC)
 733   2                      {
 734   3                      g_cFunc++;
 735   3                              key_release();
 736   3                      return 0;
 737   3                      }
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 13  

 738   2                      if(key_num == KEY_SURE)
 739   2                        {
 740   3                          g_iProtect = 0;
 741   3                          key_release();
 742   3                         Clean_Display(0,0,128,64,0);
 743   3                         if(display_Protect1(chinese2,10) == 1 )
 744   3                         {
 745   4                                i =0;
 746   4                                      while(i<5)
 747   4                                         {
 748   5                                             error = MS4515DO_read((unsigned char*)&pressure,(unsigned char*)&temper);
 749   5                                      //         MS4515DO_read((unsigned char*)&dat1,(unsigned char*)temper) == 0
 750   5                                                  if( error == 0)
 751   5                                                      {
 752   6                                                         i++;
 753   6                                                              if(pressure<=1638)
 754   6                                                          {
 755   7                                                                pressure = 1638;
 756   7                                                      }
 757   6                                                    if(pressure>=14746)
 758   6                                                  {
 759   7                                                            pressure = 14746;
 760   7                                                      }
 761   6                                                       pressure_sum =pressure_sum+pressure;
 762   6                                                       
 763   6                                                      }
 764   5                              //                      disylay_mun(i,0,7,2);
 765   5                                                      delay(500);
 766   5                                         }   
 767   4                                         pressure_sum = pressure_sum/5;
 768   4                                         g_fZero = pressure_sum*0.07751938-635;
 769   4                                         g_fZero_rev = g_fZero;
 770   4                                         Dateeprom(); 
 771   4                         }
 772   3                         Clean_Display(0,0,128,64,0);
 773   3                         display_stringChinese(0,0,chinese);
 774   3                         display_stringChar(6,1,arr);
 775   3                              windSpeed = Wid_Speed();
 776   3                      play =  (int)(windSpeed*10);
 777   3                      disylay_mun(play,1,0,1);
 778   3                      
 779   3                        }
 780   2                      if((g_iTimebase%READ_TIME) == 0)
 781   2                        {
 782   3                          windSpeed = Wid_Speed();
 783   3                              play =  (int)(windSpeed*10);
 784   3                              disylay_mun(play,1,0,1);
 785   3      //                      disylay_mun(g_fZero*100,2,0,2);   //调试用，显示零点值为多少
 786   3                        }
 787   2                      key_delay();
 788   2                  if(return_Main())
 789   2                      {
 790   3                              return 0;
 791   3                      }
 792   2              }
 793   1      }
 794          
 795          unsigned char display_WindSpeedRate()
 796          {
 797   1              unsigned char key_num;
 798   1              float windSpeed;
 799   1              unsigned int play;
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 14  

 800   1              float k1;
 801   1         code unsigned char* chinese[] ={font_26,font_27,font_05,font_06,font_00};      //精度校准
 802   1         code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};          //密码2
 803   1         code char arr[] = {'m','/','s','\0'};
 804   1           k1=g_fK1;
 805   1              display_stringChinese(0,0,chinese);
 806   1              display_stringChar(6,1,arr);
 807   1              windSpeed = Wid_Speed();
 808   1              play =  (int)(windSpeed*10);
 809   1              disylay_mun(play,1,0,1); 
 810   1              while(1)
 811   1              {
 812   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 813   2                  read_Maxout();
 814   2                      key_num = key();
 815   2                      if(key_num == KEY_FUNC)
 816   2                      {
 817   3                      g_cFunc++;
 818   3                              g_fK1 = k1;
 819   3                              key_release();
 820   3                      return 0;
 821   3                      }
 822   2      
 823   2                      if(key_num == KEY_ADD)
 824   2                        {
 825   3                         g_iProtect = 0;
 826   3                         windSpeed = Wid_Speed(); 
 827   3                         g_fK1 = (windSpeed+0.1)/windSpeed*g_fK1;
 828   3                     if(g_fK1 >= 20)
 829   3                              {
 830   4                                g_fK1 = 20;
 831   4                          }
 832   3                         if(g_fK1 <= 0.1)
 833   3                              {
 834   4                                g_fK1 = 0.1;
 835   4                          }
 836   3                              windSpeed = Wid_Speed();
 837   3                              play =  (int)(windSpeed*10);
 838   3                              disylay_mun(play,1,0,1);  
 839   3                        }
 840   2                        
 841   2                        if(key_num == KEY_SUB)
 842   2                        {
 843   3                         g_iProtect = 0;
 844   3                         windSpeed = Wid_Speed(); 
 845   3                         g_fK1 = (windSpeed-0.1)/windSpeed*g_fK1;
 846   3                     if(g_fK1 >= 20)
 847   3                              {
 848   4                                g_fK1 = 20;
 849   4                          }
 850   3                         if(g_fK1 <= 0.1)
 851   3                              {
 852   4                                g_fK1 = 0.1;
 853   4                          }
 854   3                              windSpeed = Wid_Speed();
 855   3                              play =  (int)(windSpeed*10);
 856   3                              disylay_mun(play,POINT_1,0,1);  
 857   3                        }
 858   2      
 859   2                        if(key_num == KEY_SURE)
 860   2                        {
 861   3                          g_iProtect = 0;
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 15  

 862   3                         Clean_Display(0,0,128,64,0);
 863   3                         if(display_Protect1(chinese2,10) == 0)
 864   3                           {
 865   4                                  
 866   4                                  g_fK1 = k1;
 867   4                               }
 868   3                               else
 869   3                               {
 870   4                                 Dateeprom();
 871   4                                 k1 = g_fK1;
 872   4                               }
 873   3                         Clean_Display(0,0,128,64,0);
 874   3                         display_stringChinese(0,0,chinese);
 875   3                              windSpeed = Wid_Speed();
 876   3                      play =  (int)(windSpeed*10);
 877   3                 disylay_mun(play,POINT_1,0,1);
 878   3                       //  disylay_mun(range,2,3,1);  
 879   3                        }
 880   2                       if(g_iTimebase == 1)
 881   2                       {
 882   3                         windSpeed = Wid_Speed();
 883   3                              play =  (int)(windSpeed*10);
 884   3                              disylay_mun(play,POINT_1,0,1);
 885   3                       }
 886   2                      key_delay();
 887   2                  if(return_Main())
 888   2                      {
 889   3                         // g_fK1 = k1;
 890   3                              return 0;
 891   3                      }
 892   2              //      disylay_mun(100,2,0,2);
 893   2              }
 894   1      }
 895          
 896          unsigned char display_Rate()
 897          {
 898   1              unsigned char key_num;
 899   1         unsigned int range , temp ;
 900   1          float temp_K2;                                              
 901   1         code unsigned char* chinese[] = {font_39,font_40,font_09,font_10,font_00};     //补偿系数
 902   1         code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};          //密码2
 903   1          range = g_fK2*100;
 904   1              temp_K2 = g_fK2;
 905   1       //  char arr[] = {'m','/','s','\0'};
 906   1              display_stringChinese(0,0,chinese);
 907   1      //      display_stringChar(6,1,arr);
 908   1          disylay_mun(range,2,0,1); 
 909   1              while(1)
 910   1              {
 911   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 912   2                  read_Maxout();
 913   2                      key_num = key();
 914   2                      if(key_num == KEY_FUNC)
 915   2                      {
 916   3                      g_cFunc++;
 917   3                              key_release();
 918   3                      return 0;
 919   3                      }
 920   2                      temp = key_AddSub(range,2,0,1,200);
 921   2                      range = temp;
 922   2                      if(key_num == KEY_SURE)
 923   2                      {
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 16  

 924   3                         g_iProtect = 0;
 925   3                         g_fK2 = (float)range/100;
 926   3                         Clean_Display(0,0,128,64,0);
 927   3                         if(display_Protect1(chinese2,10) == 0)
 928   3                           {
 929   4                                
 930   4                                  g_fK2 = temp_K2;
 931   4                                      range = g_fK2*100;
 932   4                               }
 933   3                               else
 934   3                               {
 935   4                                   Dateeprom();
 936   4                               }
 937   3                         Clean_Display(0,0,128,64,0);
 938   3                         display_stringChinese(0,0,chinese);
 939   3                         disylay_mun(range,2,0,1);
 940   3                      }
 941   2                       key_delay();
 942   2                  if(return_Main())
 943   2                      {
 944   3                              return 0;
 945   3                      }
 946   2              //      disylay_mun(100,2,0,2);
 947   2              }
 948   1      }
 949          
 950          unsigned char display_Renew()
 951          {
 952   1              unsigned char key_num;
 953   1              unsigned char integral,temp;
 954   1              unsigned char temp_integral;
 955   1          code unsigned char* chinese[] ={font_07,font_08,font_09,font_10,font_00};     //积分系数
 956   1          code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};         //密码2
 957   1       //  char arr[] = {'m','/','s','\0'};
 958   1          integral = g_cIntegral;
 959   1              temp_integral = g_cIntegral;
 960   1              display_stringChinese(0,0,chinese);
 961   1              disylay_mun(g_cIntegral,0,0,1);
 962   1      //      display_stringChar(6,1,arr); 
 963   1              while(1)
 964   1              {
 965   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
 966   2                  read_Maxout();
 967   2                      key_num = key();
 968   2                      if(key_num == KEY_FUNC)
 969   2                      {
 970   3                      g_cFunc++;
 971   3                              key_release();
 972   3                      return 0;
 973   3                      }
 974   2                      temp = key_AddSub(integral,0,0,1,19);
 975   2                       integral  = temp;
 976   2              if(key_num == KEY_SURE)
 977   2                      {
 978   3                         g_iProtect = 0;
 979   3                         g_cIntegral = integral;
 980   3                         Clean_Display(0,0,128,64,0);
 981   3                         if(display_Protect1(chinese2,10) == 0)
 982   3                         {
 983   4                           
 984   4                           g_cIntegral = temp_integral;
 985   4                               integral = g_cIntegral; 
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 17  

 986   4                         }
 987   3                         else
 988   3                         {
 989   4                           Dateeprom();
 990   4                         }
 991   3                         Clean_Display(0,0,128,64,0);
 992   3                         display_stringChinese(0,0,chinese);
 993   3                         disylay_mun(integral,0,0,1);
 994   3                      }
 995   2      
 996   2                      key_delay();
 997   2                  if(return_Main())
 998   2                      {
 999   3                              return 0;
1000   3                      }
1001   2                      
1002   2              //      disylay_mun(100,2,0,2);
1003   2              }
1004   1      }
1005          
1006          unsigned char display_ZKSet()
1007          {
1008   1              unsigned char key_num;
1009   1              float k1,zero;
1010   1              unsigned char temp1,temp2;
1011   1         code unsigned char* chinese[] ={font_17,font_18,font_25,font_28,font_29};      //恢复初始值
1012   1         code unsigned char* chinese1[] ={font_30,font_29,font_00,font_00,font_00};  //原值
1013   1         code unsigned char* chinese2[] ={font_31,font_29,font_00,font_00,font_00};   //新值
1014   1         code unsigned char* chinese3[] ={font_22,font_23,er,font_00,font_00};          //密码2
1015   1       //  char arr[] = {'m','/','s','\0'};
1016   1             k1 = g_fK1;
1017   1                 zero = g_fZero;
1018   1              display_stringChinese(0,0,chinese);
1019   1      //      display_stringChar(6,1,arr); 
1020   1           if((g_fZero>(g_fZero_rev-0.01)&&g_fZero<(g_fZero_rev+0.01)) && g_fK1>0.99 && g_fK1<1.01 )
1021   1                 {
1022   2                    display_stringChinese(0,1,chinese1);
1023   2                 }
1024   1                 else
1025   1                 {
1026   2                    display_stringChinese(0,1,chinese2);
1027   2                 }
1028   1              while(1)
1029   1              {
1030   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1031   2                  read_Maxout();
1032   2                      key_num = key();
1033   2                      if(key_num == KEY_FUNC)
1034   2                      {
1035   3                      g_cFunc++;
1036   3                              key_release();
1037   3                      return 0;
1038   3                      }
1039   2                      if(key_num == KEY_SURE)
1040   2                      {
1041   3                         temp1 = IapReadByte(ZERO_ADD_REV_1);
1042   3                         temp2 = IapReadByte(ZERO_ADD_REV_2);
1043   3                         g_fZero_rev = (temp1*100+temp2)/100;
1044   3                         g_iProtect = 0;
1045   3                         g_fK1 = 1.0;
1046   3                         g_fZero =g_fZero_rev ;
1047   3                         Clean_Display(0,0,128,64,0);
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 18  

1048   3      
1049   3                         if(display_Protect1(chinese3,10)==0)
1050   3                           {
1051   4                                 
1052   4                                 g_fK1 = k1;
1053   4                                 g_fZero = zero;
1054   4                               }
1055   3                               else
1056   3                               {
1057   4                                Dateeprom();
1058   4                               }
1059   3                         Clean_Display(0,0,128,64,0);
1060   3                         display_stringChinese(0,0,chinese);
1061   3                         if((g_fZero>(g_fZero_rev-0.01)&&g_fZero<(g_fZero_rev+0.01)) && g_fK1>0.99 && g_fK1<1.01 )
1062   3                     {
1063   4                       display_stringChinese(0,1,chinese1);
1064   4                     }
1065   3                     else
1066   3                     {
1067   4                       display_stringChinese(0,1,chinese2);
1068   4                     }        
1069   3                      }
1070   2      
1071   2      
1072   2                      key_delay();
1073   2                  if(return_Main())
1074   2                      {
1075   3                              return 0;
1076   3                      }
1077   2              //      disylay_mun(100,2,0,2);
1078   2              }
1079   1      }
1080          
1081          
1082          unsigned char display_uint()
1083          {
1084   1              unsigned char key_num;
1085   1              char uint1 ;
1086   1              char temp_uint1;
1087   1        code unsigned char* chinese[] ={font_15,font_16,font_00,font_00,font_00};       //单位
1088   1        code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};   //密码2
1089   1        code char arr0[] = {'m',59,'/','s',' ',' ','\0'};
1090   1        code char arr1[] = {'m',59,'/','m','i','n','\0'};
1091   1         uint1 = g_cUint;
1092   1         temp_uint1 = g_cUint;
1093   1              display_stringChinese(0,0,chinese);
1094   1               if(uint1 == 1)
1095   1                {
1096   2                        display_stringChar(3,1,arr1);
1097   2                }
1098   1                 else
1099   1                {
1100   2                        display_stringChar(3,1,arr0);
1101   2                }
1102   1              while(1)
1103   1              {
1104   2                 if(g_cMaxOut ==0 || g_cMaxOut ==2)
1105   2                  read_Maxout();
1106   2                      key_num = key();
1107   2                      if(key_num == KEY_FUNC)
1108   2                      {
1109   3                      g_cFunc++;
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 19  

1110   3                              key_release();
1111   3                      return 0;
1112   3                      }
1113   2              if(key_num == KEY_ADD)
1114   2                       {
1115   3                          g_iProtect = 0;
1116   3                          uint1++;
1117   3                              if(uint1 == 2)
1118   3                                uint1 = 0;
1119   3                         if(uint1 == 1)
1120   3                         {
1121   4                           display_stringChar(3,1,arr1);
1122   4                         }
1123   3                         else
1124   3                         {
1125   4                           display_stringChar(3,1,arr0);
1126   4                         }
1127   3                       }
1128   2                       if(key_num == KEY_SUB)
1129   2                       {
1130   3                         g_iProtect = 0;
1131   3                         uint1--;
1132   3                         if(uint1 < 0)
1133   3                          uint1 = 1;
1134   3                              if(uint1 == 1)
1135   3                         {
1136   4                           display_stringChar(3,1,arr1);
1137   4                         }
1138   3                         else
1139   3                         {
1140   4                           display_stringChar(3,1,arr0);
1141   4                         }
1142   3                       }
1143   2      
1144   2                       if(key_num == KEY_SURE)
1145   2                         {
1146   3                             g_iProtect = 0;
1147   3                             g_cUint = uint1;
1148   3                                 Clean_Display(0,0,128,64,0);
1149   3                             if(display_Protect1(chinese2,10)==0)
1150   3                                   {
1151   4                                          g_cUint = temp_uint1;
1152   4                                              uint1 = g_cUint;
1153   4                                       }
1154   3                                       else
1155   3                                       {
1156   4                                         Dateeprom();
1157   4                                       }
1158   3                             Clean_Display(0,0,128,64,0);
1159   3                             display_stringChinese(0,0,chinese);
1160   3                                 if(uint1 == 1)
1161   3                                 {
1162   4                                   display_stringChar(3,1,arr1);
1163   4                                 }
1164   3                                 else
1165   3                                 {
1166   4                                   display_stringChar(3,1,arr0);
1167   4                                 }
1168   3                         }
1169   2      
1170   2                      key_delay();
1171   2                  if(return_Main())
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 20  

1172   2                      {
1173   3                              return 0;
1174   3                      }
1175   2              //      disylay_mun(100,2,0,2);
1176   2              }
1177   1      
1178   1      }
1179          
1180          unsigned char display_workchang()
1181          {
1182   1              unsigned char key_num;
1183   1              char workChange ;
1184   1              char temp_workChange;
1185   1        code unsigned char* chinese[] ={font_38,font_02,lei,xin,font_00};       //流量类型
1186   1        code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};   //密码2
1187   1        code unsigned char* chinese_isCh4[] ={gong,kuang,font_38,font_02,font_00};      //纯甲烷流量  此处改成工况
1188   1        code unsigned char* chinese_noCh4[] ={biao,kuang,font_38,font_02,font_00};      //混合流量  此处改成标况
1189   1         workChange = g_cWorkChange;
1190   1         temp_workChange = g_cWorkChange;
1191   1              display_stringChinese(0,0,chinese);
1192   1               if(workChange == 1)
1193   1                {
1194   2                   display_stringChinese(0,1,chinese_isCh4);
1195   2                }
1196   1                 else
1197   1                {
1198   2                        display_stringChinese(0,1,chinese_noCh4);
1199   2                }
1200   1              while(1)
1201   1              {
1202   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1203   2                  read_Maxout();
1204   2                      key_num = key();
1205   2                      if(key_num == KEY_FUNC)
1206   2                      {
1207   3                      g_cFunc++;
1208   3                              key_release();
1209   3                      return 0;
1210   3                      }
1211   2              if(key_num == KEY_ADD)
1212   2                       {
1213   3                          g_iProtect = 0;
1214   3                          workChange++;
1215   3                              if(workChange == 2)
1216   3                                workChange = 0;
1217   3                         if(workChange == 1)
1218   3                         {
1219   4                           display_stringChinese(0,1,chinese_isCh4);
1220   4                         }
1221   3                         else
1222   3                         {
1223   4                           display_stringChinese(0,1,chinese_noCh4);
1224   4                         }
1225   3                       }
1226   2                       if(key_num == KEY_SUB)
1227   2                       {
1228   3                         g_iProtect = 0;
1229   3                         workChange--;
1230   3                         if(workChange < 0)
1231   3                          {
1232   4                            workChange = 1;
1233   4                              }
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 21  

1234   3                              if(workChange == 1)
1235   3                         {
1236   4                           display_stringChinese(0,1,chinese_isCh4);
1237   4                         }
1238   3                         else
1239   3                         {
1240   4                           display_stringChinese(0,1,chinese_noCh4);
1241   4                         }
1242   3                       }
1243   2      
1244   2                       if(key_num == KEY_SURE)
1245   2                         {
1246   3                             g_iProtect = 0;
1247   3                             g_cWorkChange = workChange;
1248   3                                 Clean_Display(0,0,128,64,0);
1249   3                             if(display_Protect1(chinese2,10)==0)
1250   3                                   {
1251   4                                          g_cWorkChange = temp_workChange;
1252   4                                              workChange = g_cWorkChange;
1253   4                                       }
1254   3                                       else
1255   3                                       {
1256   4                                         Dateeprom();
1257   4                                       }
1258   3                             Clean_Display(0,0,128,64,0);
1259   3                             display_stringChinese(0,0,chinese);
1260   3                                 if(workChange == 1)
1261   3                                 {
1262   4                                   display_stringChinese(0,1,chinese_isCh4);
1263   4                                 }
1264   3                                 else
1265   3                                 {
1266   4                                   display_stringChinese(0,1,chinese_noCh4);
1267   4                                 }
1268   3                         }
1269   2      
1270   2                      key_delay();
1271   2                  if(return_Main())
1272   2                      {
1273   3                              return 0;
1274   3                      }
1275   2              }
1276   1      
1277   1      }
1278          
1279          
1280          unsigned char display_MaxOut()
1281          {
1282   1              unsigned char key_num;
1283   1              char maxout ;
1284   1              char temp_maxout;
1285   1              char flag = 0;
1286   1          unsigned char* chineseClear[] ={qing,font_03,font_00,font_00,font_00};        //清零选择
1287   1              code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};     //密码2
1288   1         code char arrOFF[] = {'O','F','F',' ','\0'};
1289   1         code char arrON[] =  {'O','N',' ',' ','\0'};
1290   1        // code char arrm3[] = {'m',59,'\0'};
1291   1       //  code char arr[] = {':','\0'};
1292   1      
1293   1         maxout = g_cMaxOut;
1294   1         temp_maxout = g_cMaxOut;
1295   1      
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 22  

1296   1         mian2_chinese();
1297   1      
1298   1              while(1)
1299   1              {
1300   2                  if(maxout == 0 || maxout == 2)
1301   2                      {
1302   3                    read_Maxout();
1303   3                      }
1304   2                      if(0 == flag && g_iTimebase <= 5  )
1305   2                              {
1306   3                                          flag = 1;
1307   3                                              display_sum(g_fSum,5,1); //显示工况累积值
1308   3                                              display_sum(g_fSum_biao,5,2); //显示工况累积值
1309   3                                              display_sum(g_fSum_biao_ch4,5,3);
1310   3                                              //display_sum(12345678,6,3);
1311   3      
1312   3                              }
1313   2                              else if(g_iTimebase>5)
1314   2                              {
1315   3                                           flag = 0 ;
1316   3                              }                 
1317   2                      
1318   2                      key_num = key();
1319   2                      if(key_num == KEY_FUNC)
1320   2                      {
1321   3                      g_cFunc++;
1322   3                              key_release();
1323   3                      return 0;
1324   3                      }
1325   2              if(key_num == KEY_ADD)
1326   2                       {
1327   3                          g_iProtect = 0;
1328   3                          maxout++;
1329   3                              if(maxout == 3)
1330   3                                maxout = 0;
1331   3                         if(maxout == 1)
1332   3                         {
1333   4                           display_stringChar(7,0,arrOFF);
1334   4                         }
1335   3                         else if(maxout == 0)
1336   3                         {
1337   4                           display_stringChar(7,0,arrON);
1338   4                         }
1339   3                         else
1340   3                         {
1341   4                           display_stringChinese(7,0,chineseClear);
1342   4                         }
1343   3                       }
1344   2                       if(key_num == KEY_SUB)
1345   2                       {
1346   3                         g_iProtect = 0;
1347   3                         maxout--;
1348   3                         if(maxout < 0)
1349   3                          maxout = 2;
1350   3                              if(maxout == 1)
1351   3                         {
1352   4                           display_stringChar(7,0,arrOFF);
1353   4                         }
1354   3                         else if(maxout == 0)
1355   3                         {
1356   4                           display_stringChar(7,0,arrON);
1357   4                         }
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 23  

1358   3                         else
1359   3                         {
1360   4                           display_stringChinese(7,0,chineseClear);
1361   4                         }
1362   3      
1363   3                       }
1364   2      
1365   2                       if(key_num == KEY_SURE)
1366   2                         {
1367   3                             g_iProtect = 0;
1368   3                             g_cMaxOut = maxout;
1369   3                                 Clean_Display(0,0,128,64,0);
1370   3                             if(display_Protect1(chinese2,10)==0)
1371   3                                   {
1372   4                                          g_cMaxOut = temp_maxout;
1373   4                                              maxout = g_cMaxOut;
1374   4                                       }
1375   3                                       else
1376   3                                       {
1377   4                                         if(maxout == 2)
1378   4                                           {
1379   5                                                  g_fSum = 0.0;
1380   5                                                      g_fSum_biao = 0.0;
1381   5                                                      g_fSum_biao_ch4 = 0.0;
1382   5                                               }
1383   4                                         Dateeprom();
1384   4                                       }
1385   3                             Clean_Display(0,0,128,64,0);
1386   3                            mian2_chinese();
1387   3                                display_sum(g_fSum,5,1); //显示工况累积值
1388   3                                display_sum(g_fSum_biao,5,2); //显示工况累积值
1389   3                                display_sum(g_fSum_biao_ch4,5,3); 
1390   3                         }
1391   2      
1392   2                      key_delay();
1393   2                  if(return_Main())
1394   2                      {
1395   3                              return 0;
1396   3                      }
1397   2              }
1398   1      
1399   1      }  
1400          unsigned char display_Range()
1401          {
1402   1              unsigned char key_num;
1403   1              unsigned int range,rangeMin,temp_range,temp_rangeMin;
1404   1      
1405   1        code unsigned char* chinese[] ={font_02,font_21,font_00,font_00,font_00};       //量程
1406   1        code unsigned char* chinese2[] ={font_22,font_23,er,font_00,font_00};   //密码2
1407   1        code char arr0[] = {'m',59,'/','s',' ',' ','\0'};
1408   1        code char arr1[] = {'m',59,'/','m','i','n','\0'};
1409   1           range = g_iRange;
1410   1               temp_range = range;
1411   1               rangeMin = g_iRangeMin;
1412   1               temp_rangeMin = rangeMin;
1413   1              display_stringChinese(0,0,chinese);
1414   1              if(g_cUint == 0)
1415   1              {
1416   2                display_stringChar(5,1,arr0);
1417   2                disylay_mun(range,0,0,1);
1418   2              }
1419   1              else
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 24  

1420   1              {
1421   2                display_stringChar(5,1,arr1);
1422   2                disylay_mun(rangeMin,0,0,1);
1423   2              } 
1424   1              while(1)
1425   1              {
1426   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1427   2                  read_Maxout();
1428   2                      key_num = key();
1429   2                      if(key_num == KEY_FUNC)
1430   2                      {
1431   3                      g_cFunc++;
1432   3                              key_release();
1433   3                      return 0;
1434   3                      }
1435   2      
1436   2                      if(key_num == KEY_ADD)
1437   2                      {
1438   3                          g_iProtect = 0;
1439   3                      if(g_cUint == 0)
1440   3                                {
1441   4                                  range++;
1442   4                                      if(range > 10)
1443   4                                       {
1444   5                                        range = 10;
1445   5                                       }
1446   4                                       disylay_mun(range,0,0,1);
1447   4                                }
1448   3                                else
1449   3                                {
1450   4                                  rangeMin = rangeMin+5;
1451   4                                      if(rangeMin > 1000)
1452   4                                         rangeMin = 1000;
1453   4                                      disylay_mun(rangeMin,0,0,1);
1454   4                                }
1455   3                      }
1456   2      
1457   2                      if(key_num == KEY_SUB)
1458   2                      {
1459   3                          g_iProtect = 0;
1460   3                      if(g_cUint == 0)
1461   3                                {
1462   4                                  range--;
1463   4                                      if(range == 0)
1464   4                                       {
1465   5                                        range = 1;
1466   5                                       }
1467   4                                       disylay_mun(range,0,0,1);
1468   4                                }
1469   3                                else
1470   3                                {
1471   4                                  rangeMin = rangeMin-5;
1472   4                                      if(rangeMin == 0)
1473   4                                         rangeMin = 5;
1474   4                                      disylay_mun(rangeMin,0,0,1);
1475   4                                }
1476   3                      }
1477   2      
1478   2                      if(key_num == KEY_SURE)
1479   2                        {
1480   3                             g_iProtect = 0;
1481   3                             g_iRange =range;
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 25  

1482   3                         g_iRangeMin = rangeMin ;
1483   3                                 Clean_Display(0,0,128,64,0);
1484   3                             if(display_Protect1(chinese2,10)==0)
1485   3                                   {
1486   4                                         g_iRange = temp_range;
1487   4                                         g_iRangeMin = temp_rangeMin;
1488   4                                         range = g_iRange;
1489   4                                         rangeMin = g_iRangeMin;
1490   4                                       }
1491   3                                       else
1492   3                                       {
1493   4                                         Dateeprom();
1494   4                                       }
1495   3                             Clean_Display(0,0,128,64,0);
1496   3                             display_stringChinese(0,0,chinese);
1497   3                                      if(g_cUint == 0)
1498   3                                      {
1499   4                                        display_stringChar(5,1,arr0);
1500   4                                        disylay_mun(range,0,0,1);
1501   4                                      }
1502   3                                      else
1503   3                                      {
1504   4                                        display_stringChar(5,1,arr1);
1505   4                                        disylay_mun(rangeMin,0,0,1);
1506   4                                      } 
1507   3                        }
1508   2      
1509   2                      key_delay();
1510   2                  if(return_Main())
1511   2                      {
1512   3                              return 0;
1513   3                      }
1514   2              //      disylay_mun(100,2,0,2);
1515   2              }
1516   1      }
1517          
1518          unsigned char display_Protect1(unsigned char ** chinese,char num)
1519          {
1520   1              unsigned char key_num;
1521   1      //      unsigned char i;
1522   1          
1523   1         unsigned char password=0;
1524   1       //  unsigned char* chinese[] ={font_22,font_23,yi,font_00,font_00};      //密码1
1525   1         code char arrOK[] = {'O','K',' ',' ',' ','\0'};
1526   1         code char arrNO[] = {'N','O',' ',' ',' ','\0'};
1527   1         code char arr[] = {'e','r','r','\0'};
1528   1              display_stringChinese(0,0,chinese);
1529   1              
1530   1        //    display_stringChar(6,1,arr); 
1531   1          disylay_mun(password,0,0,1);
1532   1              key_release();
1533   1              while(1)
1534   1              {
1535   2                  if(g_cMaxOut ==0 || g_cMaxOut ==2)
1536   2                  read_Maxout();
1537   2                      key_num = key();
1538   2      //              if(key_num == KEY_FUNC)
1539   2      //              {
1540   2      //                      key_release();
1541   2      //              return 0;
1542   2      //              }                                                                                                                                                                               `
1543   2                      if(key_num == KEY_ADD)
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 26  

1544   2                      {
1545   3                         g_iProtect = 0;
1546   3                         password++;
1547   3                         disylay_mun(password,0,0,1);
1548   3                        
1549   3                      }
1550   2                      if(key_num == KEY_SUB)
1551   2                      {
1552   3                         g_iProtect = 0;
1553   3                         password--;
1554   3                         disylay_mun(password,0,0,1);
1555   3                        
1556   3                      }
1557   2                      if(key_num == KEY_SURE)
1558   2                      {
1559   3                         key_release();
1560   3                         g_iProtect = 0;
1561   3                         if(password == num)
1562   3                           {
1563   4                                      display_stringChar(0,1,arrOK);
1564   4                                      delay(1000);
1565   4                                      g_cFunc = 1;
1566   4                                      return 1;
1567   4                               }
1568   3                               else
1569   3                               {
1570   4                                      display_stringChar(0,1,arrNO);
1571   4                                      delay(1000);
1572   4                                      disylay_mun(password,0,0,1);
1573   4                                      if(g_cFunc == 13) 
1574   4                                        {
1575   5                                           g_cSecrit_Num++;
1576   5                                                 if(g_cSecrit_Num == 5)
1577   5                                                     g_cSecrit_Num = 4;
1578   5                                               Dateeprom();
1579   5                                               if(g_cSecrit_Num>=3)
1580   5                                                {
1581   6                                                  Clean_Display(0,0,128,64,0);
1582   6                                                       display_stringChar(6,1,arr);
1583   6                                                              while(1)
1584   6                                                      {
1585   7                                                      }
1586   6                                                }
1587   5                                        }
1588   4                               }
1589   3                      }
1590   2                      if(key_num == KEY_FUNC)
1591   2                      {
1592   3                          key_release();
1593   3                              return 0;
1594   3                      }
1595   2                         key_delay();
1596   2                              if(return_Main())
1597   2                               {
1598   3                                  return 0;
1599   3                               }
1600   2              //      disylay_mun(100,2,0,2);
1601   2              }
1602   1      }
1603          
1604          
1605          
C51 COMPILER V9.01   DISPLAY                                                               05/20/2015 21:09:19 PAGE 27  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7512    ----
   CONSTANT SIZE    =    679    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     13     303
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
